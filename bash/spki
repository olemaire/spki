#!/bin/bash
#   SPKI -  Simple Public Key Infrastructur
#   Copyright Â© 2013 Senso-Rezo
#   All rights reserved.
#   See LICENSE file for licensing information.
#   See http://github.com/olemaire/spki for more information.

# spki - spki core util (command line)

# user/context variables - have to be changed depending on user/context
DOMAIN=senso-rezo.org            # Domain name that will appear by default: change it by your company domain name
COMPANY="Senso/Rezo"             # Company name that will appear by default: change it by your company name
BITS=4096                        # Random bits used
SERVER_DAYS=7306                 # Server certificate will be vailid (new, renewed) for this period (just over 20 years...)
USER_DAYS=396                    # User certificates will be valid (new, renewed) for this period (just over 13 months...)


# SPKI internal variables - should not be changed
dir=$(cd `dirname $0` && pwd)          # directory where the SPKI is to be run
                                       # where the following sub-directories are used:
                                       # private/ : where the Certificate Authority key is stored for internal SPKI usage
                                       #   ca.key: Certificate Authority private key - MUST NOT BE DISTRIBUTED
                                       #   root_ca.conf: Certificate Authority OpenSSL configuration file
                                       # datas/ : where index, serials and DB are stored for internal SPKI usage
                                       #   index(.old): index of all certificates (and last action backup)
                                       #   serial(.old): last certificate serial issued (and last action backup)
                                       #   certs/: directory containing all certificates delivered so far
                                       #   random_bits: pseudo-Random bytes used for OpenSSL entropy
CONFIG_CA="$dir/private/root_ca.conf"  # where the Certificate Authority OpenSSL configuration file is stored



## FUNCTIONS
CheckEnv(){
# Check if the CA is operational
if [ ! -f certs/ca.pem ] || [ ! -f private/ca.key ]; then
  PrintMessage "info" "Check CA Environment reveal no pre-existing CA"
  echo "Please run $0 --init to initalize a new Certificate Authority"
  DieLogging 11 "The Certificate Authority has not (yet) been Initialized"
fi
}

InitializeCA(){
# Initialize the PKI(CA) elements - warning as purge any existing previous elements
LogToSyslog "notice" "Initialization of a Certificate Authority triggered"
if [ -f $dir/private/ca.key ] || [ -f $dir/certs/ca.pem ]; then
  LogToSyslog "notice" "A existing Certificate Environment is detected while asking to Initialize a new one"
  echo "ALERT: all previous existing certificates will be erased!" ;
  echo -e -n "Are your sure you want to continue (y/n)? " ;
  read i ;
  [ "$i" = "y" ] || DieLogging 10 "InializeCA was canceled by user";
fi
PrintMessage "notice" "Initializing Certificate Authority confirmed by user so let's go..."

LogToSyslog "notice" "cleaning existing datas..."
  rm -rf $dir/{certs,csr,datas,keys,private,p12,crl} || DieLogging 126 "InitializeCA cannot delete existing datas"
  mkdir $dir/{certs,csr,datas,keys,private,p12,crl} || DieLogging 126 "InitializeCA cannot create base directory structure"

LogToSyslog "notice" "Initializing Random Bits..."
  /usr/bin/openssl rand $BITS > $dir/datas/random_bits || DieLogging 126 "InitializeCA cannot create Random Bits"

LogToSyslog "notice" "Generating the Certificate Authority private Key..."
  sleep 1 
  /usr/bin/openssl genrsa -des3 -out $dir/private/ca.key $BITS -rand $dir/datas/random_bits || DieLogging 66 "InitializeCA cannot generate Certificate Authority private Key"
  chmod 600 $dir/private/ca.key || DieLogging 126 "InitializeCA cannot chmod the Certificate Authority private Key"

LogToSyslog "notice" "Generating Certificate Authority OpenSSL configuration file..."
  /bin/cat > $CONFIG_CA <<EOT || DieLogging 126 "InitializeCA cannot create Configuration file"
[ ca ]
default_ca              = default_CA
[ default_CA ]
dir                     = $dir
certs                   = \$dir/certs
new_certs_dir           = \$dir/datas/certs
database                = \$dir/datas/index
serial                  = \$dir/datas/serial
RANDFILE                = \$dir/datas/random_bits
certificate             = \$dir/certs/ca.pem
private_key             = \$dir/private/ca.key
default_days            = $SERVER_DAYS
default_crl_days        = 30
default_md              = sha1
preserve                = no
x509_extensions         = server_cert
policy                  = policy_anything
[ policy_match ]
countryName             = match
stateOrProvinceName     = match
organizationName        = match
organizationalUnitName  = optional
commonName              = supplied
emailAddress            = optional
[ policy_anything ]
countryName             = optional
stateOrProvinceName     = optional
localityName            = optional
organizationName        = optional
organizationalUnitName  = optional
commonName              = supplied
emailAddress            = optional
[ server_cert ]
subjectKeyIdentifier            = hash
authorityKeyIdentifier          = keyid:always
extendedKeyUsage                = serverAuth,clientAuth,msSGC,nsSGC
basicConstraints                = critical,CA:false
[ req ]
default_bits                    = $BITS
dir                             = $dir
default_keyfile                 = \$dir/private/ca.key
distinguished_name              = req_distinguished_name
x509_extensions                 = v3_ca
string_mask                     = nombstr
req_extensions                  = v3_req
[ req_distinguished_name ]
countryName                     = Country Name (2 letter code)
countryName_default             = US
countryName_min                 = 2
countryName_max                 = 2
0.organizationName              = Organization Name
0.organizationName_default      = $COMPANY
organizationalUnitName          = Security Services
organizationalUnitName_default  = $COMPANY Security Team
commonName                      = CA Name
commonName_default              = $COMPANY Root CA
commonName_max                  = 64
[ v3_ca ]
basicConstraints                = critical,CA:true
subjectKeyIdentifier            = hash
keyUsage                        = critical, keyCertSign, cRLSign
authorityKeyIdentifier          = keyid:always,issuer:always
nsCertType                      = sslCA, emailCA, objCA
nsComment                       = "Root CA Certificate"
# subjectAltName                = email:copy
[ v3_req ]
nsCertType                      = objsign,email,server
[ user_policy ]
commonName                      = supplied
emailAddress                    = supplied
[ user_cert ]
subjectAltName                  = email:copy
basicConstraints                = critical,CA:false
authorityKeyIdentifier          = keyid:always
extendedKeyUsage                = clientAuth,emailProtection
EOT
#FIXME: (btw, perhaps a good thing to keep the confs for users and servers certes - not in the same directory as certs/ but confs/ - just to be sure to keep the history in case the admin modify the conf while the PKI life?)

LogToSyslog "notice" "Self-signing the Certificate Authority Certificate"
  /usr/bin/openssl req -new -x509 -config $CONFIG_CA -days $SERVER_DAYS -key $dir/private/ca.key -out $dir/certs/ca.pem || DieLogging 66 "InitializeCA cannot Self-sign Certificate Authority Certificate"

LogToSyslog "notice" "Initializing user environment (directories and indexes)"
  if [ ! -d $dir/datas/certs ]; then
    mkdir -p $dir/datas/certs || DieLogging 126 "InitializeCA Cannot create $dir/datas/certs directory"
  fi
  if [ ! -f $dir/datas/serial ]; then
    echo '01' > $dir/datas/serial || DieLogging 126 "InitializeCA cannot create $dir/datas/serial file"
  fi
  if [ ! -f $dir/datas/index ]; then
    /bin/cp /dev/null $dir/datas/index || DieLogging 126 "InitializeCA cannot create $dir/datas/index file"
  fi

PrintMessage "notice" "$COMPANY Root Certificate Authority initialized successfully"
}

DieLogging(){
# exit with error code and associated message, sysloging too.
errorcode=$1
message=$2
echo "Error Code: $errorcode - $2 - Exiting..."
##TODO:
# - syslog (function)
# - printing error code associated message (see doc/ReturnCodes.md)
exit $errorcode
}

LogToSyslog() {
# will log to syslog
## FIXME: for no will only print message.
## TODO: use syslog
priority=$1
message=$2
echo "SYSLOG $priority - $message"
}

PrintMessage() {
# Display (console) the message, and syslog it too if priority is FIXME: priority to syslog
priority=$1
message=$2
echo "($priority) $message"
## TODO: filter priority - if match syslog list then syslog it
## FIXME: for now will syslog anyway
LogToSyslog "$priority" "$message"
}

Usage(){
# Print user help
echo "Copyright (C) Senso-Rezo - SPKI (http://github.com/olemaire/spki)

Usage: spki <option> (<subject>) 

Available options are:
    -init			 Initialize a new Certiciate Authority.
    -server <fqdn>		 Generate a Server certificate.
    -user <email>		 Generate an User certificate.
    -verify <email,fqdn>	 Verify a given certificate.
    -renew <email,fqdn>		 Renew a given certificate.
    -revoke <email,fqdn>	 Revoke a given certificate.
    -crl			 Generate a Certificate Revocation List.
    -help                        Display this short help message.

Exemples:
	spki -server www.senso-rezo.org
	spki -user olivier.lemaire@senso-rezo.org
	spki -revoke www.senso-rezo.org
	spki -renew olivier.lemaire@senso-rezo.org
	spki crl

"
}

## MAIN

case "$1" in
  -init|--init)
    echo "init"
    InitializeCA
    ;;
  -server|--server)
    CheckEnv
    echo "server $2"
    ;;
  -user|--user)
    CheckEnv
    echo "user $2"
    ;;
  -verify|--verify)
    CheckEnv #FIXME: verify we need CheckEnv there
    echo "verify $2"
    ;;
  -renew|--renew)
    CheckEnv #FIXME: verify we need CheckEnv there
    echo "renew $2"
    ;;
  -revoke|--revoke)
    CheckEnv #FIXME: verify we need CheckEnv there
    echo "revoke $2"
    ;;
  -crl|--crl)
    CheckEnv #FIXME: verify we need CheckEnv there
    echo "crl"
    ;;
  -h|-help|--help)
    Usage
    ;;
  "")
    echo "SPKI Copyright (C) Senso-Rezo - SPKI (http://github.com/olemaire/spki)"
    echo ""
    echo "Please RTFM: spki -help"
    echo ""
    ;;
  *)
    echo "SPKI invalid function call (try --help)"
    exit 127
esac

# - This Is The End
