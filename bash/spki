#!/bin/bash
#   SPKI -  Simple Public Key Infrastructur
#   Copyright Â© 2013 Senso-Rezo
#   All rights reserved.
#   See LICENSE file for licensing information.
#   See http://github.com/olemaire/spki for more information.

# spki - spki core util (command line)

# user/context variables - have to be changed depending on user/context
DOMAIN="senso-rezo.org"          # Domain name that will appear by default: change it by your company domain name
COMPANY="Senso/Rezo"             # Company name that will appear by default: change it by your company name
supportmail="sysadm"             # The Support Email address used for server certiciates
BITS=2048                        # Random bits used
SERVER_DAYS=7306                 # Server certificate will be vailid (new, renewed) for this period (just over 20 years...)
USER_DAYS=396                    # User certificates will be valid (new, renewed) for this period (just over 13 months...)


# SPKI internal variables - should not be changed
dir=$(cd `dirname $0` && pwd)          # directory where the SPKI is to be run
                                       # where the following sub-directories are used:
                                       # private/ : where the Certificate Authority key is stored for internal SPKI usage
                                       #   ca.key: Certificate Authority private key - MUST NOT BE DISTRIBUTED
                                       #   root_ca.conf: Certificate Authority OpenSSL configuration file
                                       # datas/ : where index, serials and DB are stored for internal SPKI usage
                                       #   index(.old): index of all certificates (and last action backup)
                                       #   serial(.old): last certificate serial issued (and last action backup)
                                       #   certs/: directory containing all certificates delivered so far
                                       #   random_bits: pseudo-Random bytes used for OpenSSL entropy
CONFIG_CA="$dir/private/root_ca.conf"  # where the Certificate Authority OpenSSL configuration file is stored
loggertag="SPKI"                       # Tag used for messages within syslog
loggerchan="daemon"                    # Facitily used for messages within syslog


## FUNCTIONS
CheckEnv() {
# Check if the CA is operational
if [ ! -f $dir/certs/ca.pem ] || [ ! -f $dir/private/ca.key ]; then
  PrintMessage "info" "Check CA Environment reveal no pre-existing CA"
  echo "Please run '$0 --init' to initalize a new Certificate Authority"
  DieLogging 11 "The Certificate Authority has not (yet) been Initialized"
fi
}

CheckIfExist() {
# Check it the subject already exists - return 0 if exists, 1 if not
local subject=$1
if [ ! -f $dir/certs/$subject.pem ]; then
  return 1
else
  return 0
fi
}


InitializeCA() {
# Initialize the PKI(CA) elements - warning as purge any existing previous elements
LogToSyslog "notice" "Initialization of a Certificate Authority triggered"
if [ -f $dir/private/ca.key ] || [ -f $dir/certs/ca.pem ]; then
  LogToSyslog "notice" "A existing Certificate Environment is detected while asking to Initialize a new one"
  echo "ALERT: all previous existing certificates will be erased!" ;
  echo -e -n "Are your sure you want to continue (y/n)? " ;
  read i ;
  [ "$i" = "y" ] || DieLogging 10 "InializeCA was canceled by user";
fi
PrintMessage "notice" "Initializing Certificate Authority asked by user so let's go..."

LogToSyslog "info" "cleaning existing datas..."
  rm -rf $dir/{certs,csr,datas,keys,private,p12,crl} || DieLogging 126 "InitializeCA cannot delete existing datas"
  mkdir $dir/{certs,csr,datas,keys,private,p12,crl} || DieLogging 126 "InitializeCA cannot create base directory structure"

LogToSyslog "info" "Initializing Random Bits..."
  /usr/bin/openssl rand $BITS > $dir/datas/random_bits || DieLogging 126 "InitializeCA cannot create Random Bits"

LogToSyslog "info" "Generating the Certificate Authority private Key..."
  sleep 1 
  /usr/bin/openssl genrsa -des3 -out $dir/private/ca.key $BITS -rand $dir/datas/random_bits || DieLogging 66 "InitializeCA cannot generate Certificate Authority private Key"
  chmod 600 $dir/private/ca.key || DieLogging 126 "InitializeCA cannot chmod the Certificate Authority private Key"

LogToSyslog "info" "Generating Certificate Authority OpenSSL configuration file..."
  /bin/cat > $CONFIG_CA <<EOT || DieLogging 126 "InitializeCA cannot create Configuration file"
[ ca ]
default_ca              = default_CA
[ default_CA ]
dir                     = $dir
certs                   = \$dir/certs
new_certs_dir           = \$dir/datas/certs
database                = \$dir/datas/index
serial                  = \$dir/datas/serial
RANDFILE                = \$dir/datas/random_bits
certificate             = \$dir/certs/ca.pem
private_key             = \$dir/private/ca.key
default_days            = $SERVER_DAYS
default_crl_days        = 30
default_md              = sha1
preserve                = no
x509_extensions         = server_cert
policy                  = policy_anything
[ policy_match ]
countryName             = match
stateOrProvinceName     = match
organizationName        = match
organizationalUnitName  = optional
commonName              = supplied
emailAddress            = optional
[ policy_anything ]
countryName             = optional
stateOrProvinceName     = optional
localityName            = optional
organizationName        = optional
organizationalUnitName  = optional
commonName              = supplied
emailAddress            = optional
[ server_cert ]
subjectKeyIdentifier            = hash
authorityKeyIdentifier          = keyid:always
extendedKeyUsage                = serverAuth,clientAuth,msSGC,nsSGC
basicConstraints                = critical,CA:false
[ req ]
default_bits                    = $BITS
dir                             = $dir
default_keyfile                 = \$dir/private/ca.key
distinguished_name              = req_distinguished_name
x509_extensions                 = v3_ca
string_mask                     = nombstr
req_extensions                  = v3_req
[ req_distinguished_name ]
countryName                     = Country Name (2 letter code)
countryName_default             = US
countryName_min                 = 2
countryName_max                 = 2
0.organizationName              = Organization Name
0.organizationName_default      = $COMPANY
organizationalUnitName          = Security Services
organizationalUnitName_default  = $COMPANY Security Team
commonName                      = CA Name
commonName_default              = $COMPANY Root CA
commonName_max                  = 64
[ v3_ca ]
basicConstraints                = critical,CA:true
subjectKeyIdentifier            = hash
keyUsage                        = critical, keyCertSign, cRLSign
authorityKeyIdentifier          = keyid:always,issuer:always
nsCertType                      = sslCA, emailCA, objCA
nsComment                       = "SPKI $COMPANY Root CA Certificate"
# subjectAltName                = email:copy
[ v3_req ]
nsCertType                      = objsign,email,server
[ user_policy ]
commonName                      = supplied
emailAddress                    = supplied
[ user_cert ]
subjectAltName                  = email:copy
basicConstraints                = critical,CA:false
authorityKeyIdentifier          = keyid:always
extendedKeyUsage                = clientAuth,emailProtection
EOT
#FIXME: (btw, perhaps a good thing to keep the confs for users and servers certes - not in the same directory as certs/ but confs/ - just to be sure to keep the history in case the admin modify the conf while the PKI life?)

LogToSyslog "info" "Self-signing the Certificate Authority Certificate..."
  /usr/bin/openssl req -new -x509 -config $CONFIG_CA -days $SERVER_DAYS -key $dir/private/ca.key -out $dir/certs/ca.pem || DieLogging 66 "InitializeCA cannot Self-sign Certificate Authority Certificate"

LogToSyslog "info" "Initializing user environment (directories and indexes)..."
  if [ ! -d $dir/datas/certs ]; then
    mkdir -p $dir/datas/certs || DieLogging 126 "InitializeCA Cannot create $dir/datas/certs directory"
  fi
  if [ ! -f $dir/datas/serial ]; then
    echo '01' > $dir/datas/serial || DieLogging 126 "InitializeCA cannot create $dir/datas/serial file"
  fi
  if [ ! -f $dir/datas/index ]; then
    /bin/cp /dev/null $dir/datas/index || DieLogging 126 "InitializeCA cannot create $dir/datas/index file"
  fi

PrintMessage "notice" "$COMPANY Root Certificate Authority initialized successfully."
}

CheckSubject() {
# Check if $2 (subject) is a valid subject (server fqdn or email) depending on type (server=fqdn,user=email) - if ok return 0, else return 1
#FIXME: could be mapped function $subject $type
#FIXME: type could be "user,server" to be factorisable with GenerateCert (see FIXME in GenerateCert)
local checktype=$1
local subject=$2
LogToSyslog "info" "Checking if $subject if of type $checktype..."
case "$checktype" in
  fqdn)
    local regex="^[a-z0-9!#\$%&'*+/=?^_\`{|}~-]+(\.[a-z0-9!#$%&'*+/=?^_\`{|}~-]+)*\$" #FIXME: wildcard not supported with this regexp
  ;;
  email)
    local regex="^[a-z0-9!#\$%&'*+/=?^_\`{|}~-]+(\.[a-z0-9!#$%&'*+/=?^_\`{|}~-]+)*@([a-z0-9]([a-z0-9-]*[a-z0-9])?\.)+[a-z0-9]([a-z0-9-]*[a-z0-9])?\$"
  ;;
  *)
    DieLogging 12 "Illegal function call: CheckSubject with type $checktype"
esac
if [[ $subject =~ $regex ]]; then
  return 0
else
  return 1
fi
}

GenerateOpenSSLConf() {
# Will generate adequate OpenSSL configuration file for signing
local conftype=$1
local subject=$2
LogToSyslog "info" "Generating OpenSSL $conftype config file for subject $subject..."
case "$conftype" in
  server)
    local commonname="Common Name (ex:ldap.$DOMAIN)"
    local emailaddress="Server Administrator email address"
    local emailaddressdefault="$supportmail@$DOMAIN"
    local extendedkeyusage="serverAuth, clientAuth"
    local nscerttype="server"
    ;;
  user)
    local commonname="Common Name (ex: john.doe@$DOMAIN)"
    local emailaddress="User email address"
    local emailaddressdefault="$subject"
    local extendedkeyusage="clientAuth"
    local nscerttype="client,email"
    ;;
  *)
    DieLogging 12 "Illegal function call: GenerateOpenSSLConf with type $conftype"
esac
#FIXME: (btw, perhaps a good thing to keep the confs for users and servers certes - not in the same directory as certs/ but confs/ - just to be sure to keep the history in case the admin modify the conf while the PKI life?)
local OPENSSL_CONFIG="$dir/certs/$subject.conf"
cat > $OPENSSL_CONFIG <<EOT || DieLogging 126 "GenerateOpenSSLConf cannot create Configuration file for $subject"
# OpenSSL configuration filed use to generate a certificate for $subject
[ req ]
default_bits        = $BITS
default_keyfile     = keys/$subject.key
default_md          = sha1
distinguished_name  = req_distinguished_name
x509_extension      = cert_req
string_mask         = nombstr

[ req_distinguished_name ]
countryName                     = Country Name (2 letter code)
countryName_default             = US
countryName_min                 = 2
countryName_max                 = 2
organizationName                = Organization Name
organizationName_default        = $COMPANY
organizationalUnitName          = Certificate Organization
organizationalUnitName_default  = $COMPANY Security Team
commonName                      = $commonname
commonName_default              = $subject
commonName_max                  = 64
emailAddress                    = $emailaddress
emailAddress_default            = $emailaddressdefault
emailAddress_max                = 64

[ cert_req ]
basicConstraints      = critical, CA:false
subjectKeyIdentifier  = hash
keyUsage              = digitalSignature, keyEncipherment
extendedKeyUsage      = $extendedkeyusage
nsCertType            = $nscerttype
EOT
}

GenerateCert() {
# Will generate a server of type "type" for subject "$2"
local certtype=$1
local subject=$2
LogToSyslog "info" "User asked to Generate a certificate for subject $subject with type $certtype"
case "$certtype" in
  server)
    CheckSubject "fqdn" "$subject" || DieLogging 12 "GenerateCert cannot generate a certificate for invalid FQDN ($subject)"
    GenerateOpenSSLConf "server" "$subject" 
    #FIXME: CheckSubject could be used once if type are user,server (and not email,fqdn) - see FIXME in CheckSubject
    local certdays=$SERVER_DAYS
  ;;
  user)
    CheckSubject "email" "$subject" || DieLogging 12 "GenerateCert cannot generate a certificate for invalid EMAIL ($subject)"
    GenerateOpenSSLConf "user" "$subject" 
    #FIXME: CheckSubject could be used once if type are user,server (and not email,fqdn) - see FIXME in CheckSubject
    local certdays=$USER_DAYS
  ;;
  *)
    DieLogging 12 "GenerateCert asked for an Unknown type of certificate asked ($certtype)"
esac
PrintMessage "info" "Let's generate a $certtype certificate for user $subject"
LogToSyslog "info" "Generating keys for subject $subject..."
  /usr/bin/openssl genrsa -out $dir/keys/$subject.key $BITS || DieLogging 66 "GenerateCert cannot generate key for $subject"
LogToSyslog "info" "Generating CSR for subject $subject..."
  /usr/bin/openssl req -new -config $dir/certs/$subject.conf -key $dir/keys/$subject.key -out $dir/csr/$subject.csr || DieLogging 66 "GenerateCert cannot generate a CSR for $subject"
LogToSyslog "info" "Asking the CA to sign the certificate for $subject..."
  /usr/bin/openssl ca -config $CONFIG_CA -days $certdays -out $dir/certs/$subject.txt -infiles $dir/csr/$subject.csr || DieLogging 66 "GenerateCert cannot make the CSR signed by the CA for subject $subject"
LogToSyslog "info" "Extracting certificate for subject $subject..."
  /usr/bin/perl -n -e 'm/BEGIN CERTIFICATE/ && do {$$seen=1}; $$seen && print;' < $dir/certs/$subject.txt > $dir/certs/$subject.pem || DieLogging 12 "GenerateCert cannot extract certificate for subject $subject" #FIXME: ErrorCode 12? sure?
LogToSyslog "info" "Verifying certificate for $subject..."
  #/usr/bin/openssl verify -CAfile $dir/certs/ca.pem $dir/certs/$subject.pem || DieLogging 126 "GenerateCert cannot verify certificate for subject $subject" 
  #FIXME: use VerifyCert ?
  VerifyCert $subject || DieLogging 126 "GenerateCert certificate verification failed (INVALID) for subject $subject"
PrintMessage "info" "Certificate ($certtype) generated for $subject"
PrintMessage "info" " -> CA certificate: $dir/certs/ca.pem"
PrintMessage "info" " -> Subject certificate: $dir/certs/$subject.pem"
PrintMessage "info" " -> Subject private key: $dir/keys/$subject.key"
PrintMessage "info" "Have a nice day."
}

VerifyCert() {
# Will verify certificate for subjet $1 (must exists - see CheckIfExist)
local subject=$1
local result=$(/usr/bin/openssl verify -CAfile $dir/certs/ca.pem $dir/certs/$subject.pem) || DieLogging 126 "VerifyCert cannot verify certificate for subject $subject" 
local regex=".*$subject.pem: OK\$"
if [[ $result =~ $regex ]]; then
  LogToSyslog "info" "VerifyCert check OK: $result"
  return 0
else 
  LogToSyslog "info" "VerifyCert check INVALID: $result"
  return 1
fi
}

DieLogging() {
# exit with error code and associated message, sysloging too.
local errorcode=$1
local message=$2
echo "Error Code: $errorcode - $message - Exiting..."
case "$errorcode" in
  0)
    LogToSyslog "notice" "(notice) - nobody should die with exit return code 0 - called with message $message"
    ;;
  10|11|12|13|14)
    LogToSyslog "notice" "$message"
    ;;
  66)
    LogToSyslog "emerg" "$message"
    ;;
  1|2|126|255)
    LogToSyslog "crit" "$message"
    ;;
  *)
    LogToSyslog "notice" "(notice) - Unknown Error Code - $errorcode - called with message $message"
esac
exit $errorcode
}

LogToSyslog() {
# will log to syslog
local priority=$1
local message=$2
case "$priority" in 
  emerg|alert|crit|notice|info|debug)
    /usr/bin/logger -p $loggerchan.$priority -t $loggertag \"$priority - $message\"
    ;;
  err|error)
    /usr/bin/logger -p $loggerchan.err -t $loggertag \"$priority - $message\"
    ;;
  warn|warning)
    /usr/bin/logger -p $loggerchan.warn -t $loggertag \"$priority - $message\"
    ;;
  *)
    /usr/bin/logger -p $loggerchan.notice -t $loggertag \"notice - syslog priority unknown -> $priority \"
    /usr/bin/logger -p $loggerchan.notice -t $loggertag \"$priority - $message\"
esac
}

PrintMessage() {
# Display (console) the message, and syslog it too if not "info" priority
local priority=$1
local message=$2
echo "($priority) $message"
if [ $priority != "info" ]; then
  LogToSyslog "$priority" "$message"
fi
}

Usage() {
# Print user help
echo "Copyright (C) Senso-Rezo - SPKI (http://github.com/olemaire/spki)

Usage: spki <option> (<subject>) 

Available options are:
    -init			 Initialize a new Certiciate Authority.
    -server <fqdn>		 Generate a Server certificate.
    -user <email>		 Generate an User certificate.
    -verify <email,fqdn>	 Verify a given certificate.
    -renew <email,fqdn>		 Renew a given certificate.
    -revoke <email,fqdn>	 Revoke a given certificate.
    -crl			 Generate a Certificate Revocation List.
    -status                      Will give information on the SPKI status
    -help                        Display this short help message.

Exemples:
	spki -server www.senso-rezo.org
	spki -user olivier.lemaire@senso-rezo.org
	spki -revoke www.senso-rezo.org
	spki -renew olivier.lemaire@senso-rezo.org
	spki crl

"
}

## MAIN

case "$1" in
  -init|--init|init)
    InitializeCA
    ;;
  -server|--server|server)
    CheckEnv
    if CheckIfExist $2 ; then
      DieLogging 14 "Trying to generate a server certificate that already exists ($2)"
    else
      GenerateCert "server" $2
    fi
    ;;
  -user|--user|user)
    CheckEnv
    if CheckIfExist $2 ; then
      DieLogging 14 "Trying to generate a user certificate that already exists ($2)"
    else
      GenerateCert "user" $2
    fi
    ;;
  -verify|--verify|verify)
    CheckEnv 
    CheckIfExist $2 || DieLogging 13 "Subject $2 does not exists!"
    if VerifyCert $2 ; then
      echo "Certificate for $2 is VALID"
      exit 0
    else
      echo "Certificate for $2 is INVALID"
      exit 100
    fi
    ;;
  -renew|--renew|renew)
    CheckEnv
    echo "renew $2"
    echo "Not Implemented yet"
    ;;
  -revoke|--revoke|revoke)
    CheckEnv
    echo "revoke $2"
    echo "Not Implemented yet"
    ;;
  -crl|--crl|crl)
    CheckEnv
    echo "crl"
    echo "Not Implemented yet"
    ;;
  -status|--status|status)
    echo "status"
    echo "Not Implemented yet"
    ;;
  -h|-help|--help|help)
    Usage
    ;;
  "")
    echo "SPKI Copyright (C) Senso-Rezo - SPKI (http://github.com/olemaire/spki)"
    echo ""
    echo "Please RTFM: spki -help"
    echo ""
    ;;
  *)
    DieLogging 12 "SPKI invalid function call \"$1\" (try --help)"
esac

# TODO:
# 	- server,user : does CheckIfExist cannot be factorised at the begining of GenerateCert (instead of being called at the end twice) ? 
#	- verify: does CheckIfExist cannot be factorised at the begining of VerifyCert (instead of long command at the end) ?
# - This Is The End
