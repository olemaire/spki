#!/bin/bash
#   SPKI -  Simple Public Key Infrastructur
#   Copyright Â© 2013 Senso-Rezo
#   All rights reserved.
#   See LICENSE file for licensing information.
#   See http://github.com/olemaire/spki for more information.

# spki - spki core util (command line)

# user/context variables - have to be changed depending on user/context
COUNTRY="US"                     # Country Code you want to registrer the PKI to (must be 2 letter country code)
DOMAIN="senso-rezo.org"          # Domain name that will appear by default: change it by your company domain name
COMPANY="Senso-Rezo"             # Company name that will appear by default: change it by your company name
supportmail="sysadm"             # The Support Email address used for server certiciates
BITS=2048                        # Random bits used
SERVER_DAYS=7306                 # Server certificate will be issued (new, renewed) for this period (just over 20 years...)
USER_DAYS=396                    # User certificates will be issued (new, renewed) for this period (just over 13 months...)
CRL_DAYS=31                      # Days between each CRL is due

# user/context automation mode - have to be changed depending on user context
automated="yes"                          # Define if SPKI must be full automated or not (yes/not)


# SPKI internal variables - should not be changed unless you perfectly know what your are doing (and prepare to debug)
dir=$(cd `dirname $0` && pwd)            # directory where the SPKI is to be run
                                         # where the following sub-directories are used:
                                         # private/ : where the Certificate Authority key is stored for internal SPKI usage
                                         #   ca.key: Certificate Authority private key - MUST NOT BE DISTRIBUTED
                                         #   root_ca.conf: Certificate Authority OpenSSL configuration file
                                         # datas/ : where index, serials and DB are stored for internal SPKI usage
                                         #   index(.old): index of all certificates (and last action backup)
                                         #   serial_cert(.old): next certificate serial to ve used (and last action backup)
                                         #   serial_crl(.old): next CRL serial to be used (and last action backup)
                                         #   certs/: directory containing all certificates delivered so far
                                         #   random_bits: pseudo-Random bytes used for OpenSSL entropy
CONFIG_CA="$dir/private/root_ca.conf"    # where the Certificate Authority OpenSSL configuration file is stored
loggertag="SPKI"                         # Tag used for messages within syslog
loggerchan="daemon"                      # Facitily used for messages within syslog
debugmode="no"                           # Activate/Desactivate the debug mode (yes/no) - default no


## FUNCTIONS
CheckEnv() {
# Check if the CA is operational
if [ ! -f $dir/certs/ca.pem ] || [ ! -f $dir/private/ca.key ]; then
  PrintMessage "emerg" "Check CA Environment reveal no pre-existing CA"
  echo "##### Please run '$0 --init' to initalize a new Certificate Authority"
  DieLogging 11 "The Certificate Authority has not (yet) been Initialized"
fi
}

CheckConfig() {
# Check if config is consistent
case "$automated" in
  yes|on|no|not|off)
    LogToSyslog "debug" "CheckConfig: automated mode asked is supported ($automated)"
    ;;
  *)
    DieLogging 9 "CheckConfig: automated mode not supported ($automated)!!!" 
esac
case "$debugmode" in
  yes|no)
    LogToSyslog "debug" "CheckConfig: debug mode is supported ($debugmode)"
    ;;
  *)
    DieLogging 9 "CheckConfig: debugmode not supported ($debugmode)!!!" 
esac
}

CheckIfExist() {
# Check it the subject already exists - return 0 if exists, 1 if not
local subject=$1
if [ ! -f $dir/certs/$subject.pem ]; then
  return 1
else
  return 0
fi
}


InitializeCA() {
# Initialize the PKI(CA) elements - warning as purge any existing previous elements
LogToSyslog "alert" "Initialization of a Certificate Authority triggered"
if [ -f $dir/private/ca.key ] || [ -f $dir/certs/ca.pem ]; then
  LogToSyslog "alert" "A existing Certificate Environment is detected while asking to Initialize a new one"
  PrintMessage "alert" "ALERT: all previous existing certificates will be erased!" ;
  echo -e -n "Are your sure you want to continue (y/n)? " ;
  read i ;
  [ "$i" = "y" ] || DieLogging 10 "InializeCA was canceled by user";
fi
PrintMessage "alert" "Initializing Root Certificate Authority for $COMPANY:"

LogToSyslog "debug" "cleaning existing datas..."
  rm -rf $dir/{certs,csr,datas,keys,private,crl} || DieLogging 126 "InitializeCA cannot delete existing datas"
  mkdir $dir/{certs,csr,datas,keys,private,crl} || DieLogging 126 "InitializeCA cannot create base directory structure"

LogToSyslog "debug" "Generating the Certificate Authority signing environment..."
  sleep 1 
  case "$automated" in
    yes|on)
      PrintMessage "info" "Automated mode is ON..."
      PrintMessage "info" "Initializing Random Bits..."
      /usr/bin/openssl rand $BITS > $dir/datas/random_bits > /dev/null 2>&1 || DieLogging 126 "InitializeCA cannot create Random Bits"
      PrintMessage "info" "Generating the Certificate Authority private Key..."
      /usr/bin/openssl genrsa -out $dir/private/ca.key $BITS -rand $dir/datas/random_bits > /dev/null 2>&1 || DieLogging 66 "InitializeCA cannot generate Certificate Authority private Key"
      ;;
    no|not|off)
      PrintMessage "info" "Automated mode is OFF..."
      /usr/bin/openssl rand $BITS > $dir/datas/random_bits || DieLogging 126 "InitializeCA cannot create Random Bits"
      PrintMessage "info" "Generating the Certificate Authority private Key..."
      /usr/bin/openssl genrsa -des3 -out $dir/private/ca.key $BITS -rand $dir/datas/random_bits || DieLogging 66 "InitializeCA cannot generate Certificate Authority private Key"
      ;;
    *)
    DieLogging 12 "InitializeCA called in an unsupported automated mode ($automated)"
  esac
  chmod 600 $dir/private/ca.key || DieLogging 126 "InitializeCA cannot chmod the Certificate Authority private Key"

LogToSyslog "debug" "Generating Certificate Authority OpenSSL configuration file..."
  /bin/cat > $CONFIG_CA <<EOT || DieLogging 126 "InitializeCA cannot create Configuration file"
[ ca ]
default_ca              = default_CA                                        # The default CA section
[ default_CA ]
dir                     = $dir                                              # Top directory
certs                   = $dir/certs                                        # Certificate repository
new_certs_dir           = $dir/datas/certs                                  # Certificate archive
database                = $dir/datas/index                                  # CA database
unique_subject          = no                                                # Require unique subject
serial                  = $dir/datas/serial_cert                            # Cert number file
crlnumber               = $dir/datas/serial_crl                             # CRL number file
RANDFILE                = $dir/datas/random_bits
certificate             = $dir/certs/ca.pem                                 # The CA certificate
private_key             = $dir/private/ca.key                               # The CA private key
default_days            = $SERVER_DAYS                                      # How long to certify for
default_crl_days        = $CRL_DAYS                                         # How long a CRL is due 
default_md              = sha1                                              # MD to use
preserve                = no                                                # Keep passed DN ordering
name_opt                = multiline,-esc_msb,utf8                           # Display UTF-8 characters
x509_extensions         = server_cert                                       # default x509v3 extensions used
policy                  = policy_anything
[ policy_match ]
countryName             = match
stateOrProvinceName     = match
organizationName        = match
organizationalUnitName  = optional
commonName              = supplied
emailAddress            = optional
[ policy_anything ]
countryName             = optional
stateOrProvinceName     = optional
localityName            = optional
organizationName        = optional
organizationalUnitName  = optional
commonName              = supplied
emailAddress            = optional
[ server_cert ]
subjectKeyIdentifier            = hash
authorityKeyIdentifier          = keyid:always
extendedKeyUsage                = serverAuth,clientAuth,msSGC,nsSGC
basicConstraints                = critical,CA:false
nsComment                       = "SPKI $COMPANY Server Certificate"
[ v3_ca ]
basicConstraints                = critical,CA:true
subjectKeyIdentifier            = hash
keyUsage                        = critical, keyCertSign, cRLSign
authorityKeyIdentifier          = keyid:always,issuer:always
nsCertType                      = sslCA, emailCA, objCA
nsComment                       = "SPKI $COMPANY Root CA Certificate"
# subjectAltName                = email:copy
[ v3_req ]
nsCertType                      = objsign,email,server
[ user_policy ]
commonName                      = supplied
emailAddress                    = supplied
[ user_cert ]
subjectAltName                  = email:copy
basicConstraints                = critical,CA:false
authorityKeyIdentifier          = keyid:always
extendedKeyUsage                = clientAuth,emailProtection
nsComment                       = "SPKI $COMPANY User Certificate"
EOT
case "$automated" in
  yes|on)
    /bin/cat >> $CONFIG_CA <<EOT || DieLogging 126 "InitializeCA cannot create Configuration file - req part"
[ req ]
default_bits                    = $BITS
dir                             = $dir
default_keyfile                 = $dir/private/ca.key
utf8                            = yes                                      # Input are dealt as UTF-8
prompt                          = no                                       # Do not prompt for DN while managing CSR - because full automated way
distinguished_name              = req_distinguished_name
x509_extensions                 = v3_ca
string_mask                     = utf8only                                 # Emit UTF-8 Strings
req_extensions                  = v3_req
[ req_distinguished_name ]
countryName                     = "$COUNTRY"
organizationName                = "$COMPANY"
organizationalUnitName          = "$COMPANY Security Services"
commonName                      = "$COMPANY Root CA"
EOT
    ;;
  no|not|off)
    /bin/cat >> $CONFIG_CA <<EOT || DieLogging 126 "InitializeCA cannot create Configuration file - req part"
[ req ]
default_bits                    = $BITS
dir                             = $dir
default_keyfile                 = $dir/private/ca.key
utf8                            = yes                                      # Input are dealt as UTF-8
distinguished_name              = req_distinguished_name
x509_extensions                 = v3_ca
string_mask                     = utf8only                                 # Emit UTF-8 Strings
req_extensions                  = v3_req
[ req_distinguished_name ]
countryName                     = Country Name (2 letter code)
countryName_default             = "$COUNTRY"
countryName_min                 = 2
countryName_max                 = 2
0.organizationName              = Organization Name
0.organizationName_default      = "$COMPANY"
organizationalUnitName          = Certificate Division
organizationalUnitName_default  = "$COMPANY Security Team"
commonName                      = CA Name
commonName_default              = "$COMPANY Root CA"
commonName_max                  = 64
EOT
    ;;
  *)
  DieLogging 12  "InitializeCA called in an unsupported automated mode ($automated)"
esac

PrintMessage "info" "Self-signing the Certificate Authority Certificate..."
  /usr/bin/openssl req -new -x509 -config $CONFIG_CA -days $SERVER_DAYS -key $dir/private/ca.key -out $dir/certs/ca.pem || DieLogging 66 "InitializeCA cannot Self-sign Certificate Authority Certificate"

PrintMessage "info" "Initializing user environment (directories and indexes)..."
  if [ ! -d $dir/datas/certs ]; then
    mkdir -p $dir/datas/certs || DieLogging 126 "InitializeCA Cannot create $dir/datas/certs directory"
  fi
  if [ ! -f $dir/datas/serial_cert ]; then
    echo '01' > $dir/datas/serial_cert || DieLogging 126 "InitializeCA cannot create $dir/datas/serial_cert file"
  fi
  if [ ! -f $dir/datas/serial_crl ]; then
    echo '01' > $dir/datas/serial_crl || DieLogging 126 "InitializeCA cannot create $dir/datas/serial_crl file"
  fi
  if [ ! -f $dir/datas/index ]; then
    /bin/cp /dev/null $dir/datas/index || DieLogging 126 "InitializeCA cannot create $dir/datas/index file"
  fi

LogToSyslog "debug" "Issuing the first Certificate Revocation List"
  /bin/cp $dir/certs/ca.pem $dir/crl/ca.pem || DieLogging 126 "InitializeCA cannot copy CA certificate to CRL directory"
  GenerateCRL || DieLogging 126 "InitializeCA cannot generate the first CRL"

PrintMessage "alert" "$COMPANY Root Certificate Authority initialized successfully."
}

CheckSubject() {
# Check if $2 (subject) is a valid subject (server fqdn or email) depending on type (server=fqdn,user=email) - if ok return 0, else return 1
local checktype=$1
local subject=$2
LogToSyslog "debug" "Checking if $subject if of type $checktype..."
case "$checktype" in
  fqdn)
    local regex="^[a-z0-9!#\$%&'*+/=?^_\`{|}~-]+(\.[a-z0-9!#$%&'*+/=?^_\`{|}~-]+)*\$" #FIXME: wildcard not supported with this regexp
  ;;
  email)
    local regex="^[a-z0-9!#\$%&'*+/=?^_\`{|}~-]+(\.[a-z0-9!#$%&'*+/=?^_\`{|}~-]+)*@([a-z0-9]([a-z0-9-]*[a-z0-9])?\.)+[a-z0-9]([a-z0-9-]*[a-z0-9])?\$"
  ;;
  *)
    DieLogging 12 "Illegal function call: CheckSubject with type $checktype"
esac
if [[ $subject =~ $regex ]]; then
  return 0
else
  return 1
fi
}

GenerateOpenSSLConf() {
# Will generate adequate OpenSSL configuration file for signing
local conftype=$1
local subject=$2
LogToSyslog "debug" "Generating OpenSSL $conftype config file for subject $subject..."
case "$conftype" in
  server)
    local commonname="Common Name (ex:ldap.$DOMAIN)"
    local emailaddress="Server Administrator email address"
    local emailaddressdefault="$supportmail@$DOMAIN"
    local extendedkeyusage="serverAuth, clientAuth"
    local nscerttype="server"
    ;;
  user)
    local commonname="Common Name (ex: john.doe@$DOMAIN)"
    local emailaddress="User email address"
    local emailaddressdefault="$subject"
    local extendedkeyusage="clientAuth"
    local nscerttype="client,email"
    ;;
  *)
    DieLogging 12 "Illegal function call: GenerateOpenSSLConf with type $conftype"
esac

local OPENSSL_CONFIG="$dir/csr/$subject.conf"

case "$automated" in
  yes|on)
    /bin/cat >> $OPENSSL_CONFIG <<EOT || DieLogging 126 "GenerateOpenSSLConf cannot create - req part"
[ req ]
default_bits          = $BITS
default_keyfile       = $dir/keys/$subject.key
default_md            = sha1
utf8                  = yes
prompt                = no                                    # do not prompt for DN validation - because full automated way
distinguished_name    = req_distinguished_name
x509_extension        = cert_req
string_mask           = utf8only

[ req_distinguished_name ]
countryName             = "$COUNTRY"
organizationName        = "$COMPANY"
organizationalUnitName  = "Operational Unit"
commonName              = $subject
emailAddress            = $emailaddressdefault

EOT
    ;;
  no|not|off)
    /bin/cat > $OPENSSL_CONFIG <<EOT || DieLogging 126 "GenerateOpenSSLConf cannot create - req part"
[ req ]
default_bits          = $BITS
default_keyfile       = $dir/keys/$subject.key
default_md            = sha1
utf8                  = yes
distinguished_name    = req_distinguished_name
x509_extension        = cert_req
string_mask           = utf8only

[ req_distinguished_name ]
countryName                      = Country Name (2 letter code)
countryName_default              = "$COUNTRY"
countryName_min                  = 2
countryName_max                  = 2
organizationName                 = Organization Name
organizationName_default         = "$COMPANY"
organizationalUnitName           = Certificate Organisation
organizationalUnitName_default   = "$COMPANY Security Team"
commonName                       = "$commonname"
commonName_default               = $subject
commonName_max                   = 64
emailAddress                     = "$emailaddress"
emailAddress_default             = "$emailaddressdefault"
emailAddress_max                 = 64

EOT
    ;;
  *)
  DieLogging 12 "GenerateOpenSSLConf called in an unsupported automated mode ($automated)"
esac

cat >> $OPENSSL_CONFIG <<EOT || DieLogging 126 "GenerateOpenSSLConf cannot create Configuration file for $subject"
# OpenSSL configuration filed use to generate a certificate for $subject
[ cert_req ]
basicConstraints      = critical, CA:false
subjectKeyIdentifier  = hash
keyUsage              = digitalSignature, keyEncipherment
extendedKeyUsage      = $extendedkeyusage
nsCertType            = $nscerttype
EOT

}

GenerateCert() {
# Will generate a server of type "type" for subject "$2"
local certtype=$1
local subject=$2

if CheckIfExist $subject ; then
  DieLogging 14 "GenerateCert: Trying to generate a $certtype certificate which already exists ($subject)"
fi


LogToSyslog "debug" "User asked to Generate a certificate for subject $subject with type $certtype"
case "$certtype" in
  server)
    CheckSubject "fqdn" "$subject" || DieLogging 12 "GenerateCert cannot generate a certificate for invalid FQDN ($subject)"
    GenerateOpenSSLConf "server" "$subject" 
    local certdays=$SERVER_DAYS
    local extensions="server_cert"
  ;;
  user)
    CheckSubject "email" "$subject" || DieLogging 12 "GenerateCert cannot generate a certificate for invalid EMAIL ($subject)"
    GenerateOpenSSLConf "user" "$subject" 
    local certdays=$USER_DAYS
    local extensions="user_cert"
  ;;
  *)
    DieLogging 12 "GenerateCert asked for an Unknown type of certificate asked ($certtype)"
esac
LogToSyslog "debug" "Let's generate a $certtype certificate for user $subject"
LogToSyslog "debug" "Generating keys for subject $subject..." 
  case "$automated" in
    yes|on)
      /usr/bin/openssl genrsa -out $dir/keys/$subject.key $BITS > /dev/null 2>&1 || DieLogging 66 "GenerateCert cannot generate key for $subject"
      ;;
    no|not|off)
      echo -e -n " |----> Protect key with a passphrase (y/n)? : [n] "
      read keyboard
      if [ "$keyboard" == "y" -o "$keyboard" == "Y" ]; then
        /usr/bin/openssl genrsa -des3 -out $dir/keys/$subject.key $BITS || DieLogging 66 "GenerateCert cannot generate key for $subject"
      else
        /usr/bin/openssl genrsa -out $dir/keys/$subject.key $BITS || DieLogging 66 "GenerateCert cannot generate key for $subject"
      fi
     ;;
    *)
    DieLogging 12 "GenerateCert called in an unsupported automated mode ($automated)"
  esac
LogToSyslog "debug" "Generating CSR for subject $subject..."
  /usr/bin/openssl req -new -config $dir/csr/$subject.conf -key $dir/keys/$subject.key -out $dir/csr/$subject.csr || DieLogging 66 "GenerateCert cannot generate a CSR for $subject"
LogToSyslog "debug" "Asking the CA to sign the certificate for $subject..."
  case "$automated" in
    yes|on)
      LogToSyslog "debug" "-> automated mode is on..."
      /usr/bin/openssl ca -batch -config $CONFIG_CA -days $certdays -extensions $extensions -out $dir/certs/$subject.txt -infiles $dir/csr/$subject.csr > /dev/null 2>&1 || DieLogging 66 "GenerateCert sign the submited CSR for subject $subject"
      ;;
    no|not|off)
      LogToSyslog "debug" "-> automated mode is off..."
      /usr/bin/openssl ca -batch -config $CONFIG_CA -days $certdays -extensions $extensions -out $dir/certs/$subject.txt -infiles $dir/csr/$subject.csr || DieLogging 66 "GenerateCert sign the submited CSR for subject $subject"
      ;;
    *)
    DieLogging 12 "GenerateCert called in an unsupported automated mode ($automated)"
  esac
LogToSyslog "debug" "Extracting certificate for subject $subject..."
  /usr/bin/perl -n -e 'm/BEGIN CERTIFICATE/ && do {$$seen=1}; $$seen && print;' < $dir/certs/$subject.txt > $dir/certs/$subject.pem || DieLogging 126 "GenerateCert cannot extract certificate for subject $subject"
LogToSyslog "debug" "Verifying certificate for $subject..."
  VerifyCert $subject || DieLogging 126 "GenerateCert certificate verification failed (INVALID) for subject $subject"
PrintMessage "info" "Certificate ($certtype) generated for $subject:"
PrintMessage "info" " - CA certificate: $dir/certs/ca.pem"
PrintMessage "info" " - Subject certificate: $dir/certs/$subject.pem"
PrintMessage "info" " - Subject private key: $dir/keys/$subject.key"
PrintMessage "info" "Have a nice day."
}

GenerateCRL() {
# Will generate a new CRL
case "$automated" in
  yes|on)
    LogToSyslog "debug" "GenerateCRL asked to generate a new CRL"
    /usr/bin/openssl ca -gencrl -config $CONFIG_CA -crldays $CRL_DAYS -out $dir/crl/current_crl.pem > /dev/null 2>&1 || DieLogging 66 "GenerateCRL cannot generate a new CRL"
    ;;
  no|not|off)
    PrintMessage "info" "Generating a new CRL..."
    /usr/bin/openssl ca -gencrl -config $CONFIG_CA -crldays $CRL_DAYS -out $dir/crl/current_crl.pem || DieLogging 66 "GenerateCRL cannot generate a new CRL"
    ;;
  *)
  DieLogging 12 "GenerateCRL called in an unsupported automated mode ($automated)"
esac
# FIXME: seems not needed unless wanting to publish outside (which should be done at the end using a "publish" function?)
#         to be seen when crl distribution point (see #5)
#/usr/bin/openssl crl -inform PEM -in $dir/crl/current_crl.pem -outform DER -out $dir/crl/current_crl.der || DieLogging 66 "GenerateCRL cannot encode CRL in DER format"


/usr/bin/c_rehash $dir/crl > /dev/null 2>&1 || DieLogging 126 "GenerateCRL cannot rehash its directory"

LogToSyslog "info" "A new CRL has been generated and CRL directory rehashed"

}

RevokeCert() {
# Will revoke the certificate for subject $1 (must exists - see CheckIfExists)
local subject=$1
local reason=$2
CheckIfExist $subject || DieLogging 13 "RevokeCert: certificate for subject $subject does not exists!"
if ! VerifyCert $subject ; then
  DieLogging 14 "RevokeCert: cerfiticate for subject $subject is already revoked!"
fi
case "$reason" in
  unspecified|keyCompromise|CACompromise|affiliationChanged|superseded|cessationOfOperation|certificateHold)
    LogToSyslog "debug" "RevokeCert: is called to revoke certificate for subject $subjet with reason $reason"
    local revocation_reason=$reason
    ;;
  "")
    LogToSyslog "debug" "RevokeCert: is called to revoke certificate for subject $subject with no reason, so defaulting to unspecified)"
    local revocation_reason="unspecified"
    ;;
  *)
    LogToSyslog "warn" "RevokeCert: is called to revoke certificate for subject $subject with unknown reason ($reason), defaulting to unspecified" 
    local revocation_reason="unspecified"
esac

PrintMessage "info" "Revoking certificate for $subject (reason = $revocation_reason):"
case "$automated" in
  yes|on)
    /usr/bin/openssl ca -revoke $dir/certs/$subject.pem -config $CONFIG_CA -crl_reason $revocation_reason > /dev/null 2>&1 || DieLogging 66 "RevokeCert: unable to revoke certificate for subject $subject"
    PrintMessage "info" " - Certificate for subject $subject has been revoked for reason $revocation_reason."
    GenerateCRL || DieLogging 126 "RevokeCert cannot generate a CRL (automated mode is $automated)"
    PrintMessage "info" " - Generating a new CRL..."
    PrintMessage "info" "Certificate for subject $subject has been revoked and a new CRL has been generated."
    ;;
  no|not|off)
    /usr/bin/openssl ca -revoke $dir/certs/$subject.pem -config $CONFIG_CA -crl_reason $revocation_reason || DieLogging 66 "RevokeCert: unable to revoke certificate for subject $subject"
    PrintMessage "info" " - Certificate for subject $subject has been revoked for reason $revocation_reason."
    PrintMessage "info" "You should think about generate a new CRL."
    ;;
  *)
  DieLogging 12 "RevokeCert called in an unsupported automated mode ($automated)"
esac
}

VerifyCert() {
# Will verify certificate for subjet $1 (must exists - see CheckIfExist)
local subject=$1
CheckIfExist $subject || DieLogging 13 "VerifyCert: Subject $2 does not exists!"

local result=$(/usr/bin/openssl verify -CApath $dir/crl/ -crl_check $dir/certs/$subject.pem) || DieLogging 126 "VerifyCert cannot verify certificate for subject $subject" 
local regex=".*$subject.pem: OK\$"

#       With OpenSSL 1.0.1y (and counting), the verify --CRLfile file.pem could do (undocumented but working option) in association with --CAfile ca.pem
#       That should avoid to use c_rehash at each CRL generation
#       But most of the 2011-2014 systems are still shipped with OpenSSL 0.9.8y ... so, need to find a generic way

if [[ $result =~ $regex ]]; then
  LogToSyslog "debug" "VerifyCert check OK: $result"
  return 0
else 
  LogToSyslog "debug" "VerifyCert check INVALID: $result"
  return 1
fi
}

PrintCRLInfo() {
# Will print human readable info about current CRL
if [ ! -f $dir/crl/current_crl.pem ]; then
  DieLogging 13 "PrintCRLInfo: no CRL present!"
else 
  echo "Printing current CRL informations:"
  /usr/bin/openssl crl -inform PEM -in $dir/crl/current_crl.pem -text -noout || DieLogging 66 "PrintCRLInfo: error trying to print CRL information"
fi
}

PrintCAInfo() {
# Will print human readable info regarding the CA
local myhost=$HOSTNAME
local opensslversion=$(/usr/bin/openssl version) || DieLogging 66 "PrintCAInfo: cannot stat on OpenSSL version"
local caissuer=$(/usr/bin/openssl x509 -noout -in $dir/certs/ca.pem -issuer) || DieLogging 66 "PrintCAInfo: cannot stat CA issuer from CA certificate"
local castartdate=$(/usr/bin/openssl x509 -noout -in $dir/certs/ca.pem -startdate) || DieLogging 66 "PrintCAInfo: cannot stat CA startdate from CA certificate"
local caenddate=$(/usr/bin/openssl x509 -noout -in $dir/certs/ca.pem -enddate) || DieLogging 66 "PrintCAInfo: cannot stat CA enddate from CA certificate"
local validcert=$(grep "^V" $dir/datas/index | /usr/bin/wc -l) || DieLogging 126 "PrintCAInfo: cannot count Valid certificates in CA index file"
local revokedcert=$(grep "^R" $dir/datas/index | /usr/bin/wc -l) || DieLogging 126 "PrintCAInfo: cannot count Revoked certificates in CA index file"
local expiredcert=$(grep "^E" $dir/datas/index | /usr/bin/wc -l) || DieLogging 126 "PrintCAInfo: cannot count Expired certificates in CA index file"
local lastcrldate=$(/usr/bin/openssl crl -inform PEM -in $dir/crl/current_crl.pem -noout -lastupdate) || DieLogging 66 "PrintCAInfo> cannot stat on CRL lastupdate"
local nextcrldate=$(/usr/bin/openssl crl -inform PEM -in $dir/crl/current_crl.pem -noout -nextupdate) || DieLogging 66 "PrintCAInfo> cannot stat on CRL nextupdate"
echo "General info on the Certificate Authority:"
echo "------------------------------------------"
echo "Host running SPKI:                          $myhost"
echo "Cryptographic Engine:                       $opensslversion"
echo "Certificate Authority DN:                   ${caissuer//issuer=\ \//}"
echo "Start Validity on:                          ${castartdate//notBefore=/}"
echo "End Validity on:                            ${caenddate//notAfter=/}"
echo "Issued certificates Valid/Revoked/Expired:  ${validcert//[[:space:]]/} / ${revokedcert//[[:space:]]/} / ${expiredcert//[[:space:]]/}"
echo "Last CRL produced on:                       ${lastcrldate//lastUpdate=/}"
echo "Next CRL to be produced on:                 ${nextcrldate//nextUpdate=/}"
echo "Current Status:                             OK"
}

PrintCertInfo() {
# Will print human readable info regarding a given certificate - if exists (else die)
local subject=$1
CheckIfExist $subject || DieLogging 13 "PrintCertInfo: Subject $2 does not exists!"
echo "Printing certificate information for $subject:" 
/usr/bin/openssl x509 -text -in $dir/certs/$subject.pem -noout || DieLogging 66 "PrintCertInfo: error trying to print Cert information for $subject"
}


DieLogging() {
# exit with error code and associated message, sysloging too.
local errorcode=$1
local message=$2
case "$errorcode" in
  0|100)
    PrintMessage "warn" "Nobody should die with exit return code 0 or 100 - called with message $message"
    ;;
  12)
    PrintMessage "warn" "$message"
    ;;
  9|66)
    PrintMessage "emerg" "$message"
    ;;
  1|2|126|255)
    PrintMessage "crit" "$message"
    ;;
  13|14)
    PrintMessage "debug" "$message"
    ;;
  10|11)
    PrintMessage "info" "$message"
    ;;
  *)
    PrintMessage "warn" "Unknown Error Code($errorcode): called with message $message"
esac
    PrintMessage "info" "Exiting with Error Code $errorcode..."
exit $errorcode
}

LogToSyslog() {
# will log to syslog
local priority=$1
local message=$2
case "$priority" in 
  debug)
    if [ "$debugmode" == "yes" ]; then
      /usr/bin/logger -p $loggerchan.$priority -t $loggertag "$priority - $message"
    fi
    ;;
  emerg|alert|crit|notice|info)
    /usr/bin/logger -p $loggerchan.$priority -t $loggertag "$priority - $message"
    ;;
  err|error)
    /usr/bin/logger -p $loggerchan.err -t $loggertag "$priority - $message"
    ;;
  warn|warning)
    /usr/bin/logger -p $loggerchan.warn -t $loggertag "$priority - $message"
    ;;
  *)
    /usr/bin/logger -p $loggerchan.warning -t $loggertag "notice - syslog priority unknown -> $priority"
    /usr/bin/logger -p $loggerchan.warning -t $loggertag "$priority - $message"
esac
}

PrintMessage() {
# Display (console) the message, and syslog it too if not "info" priority
local priority=$1
local message=$2
case "$priority" in
  debug)
    echo "----> $message" 
    if [ "$debugmode" == "yes" ]; then
      LogToSyslog "$priority" "$message"
    fi
    ;;
  info)
    echo "----> $message"
    if [ "$debugmode" == "yes" ]; then
      LogToSyslog "$priority" "$message"
    fi
    ;;
  warn|warning)
    echo "##### $message"
    LogToSyslog "$priority" "$message"
    ;;
  crit|alert)
    echo "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
    echo "!!!!! $message"
    LogToSyslog "$priority" "$message"
    ;;
  emerg)
    echo "********************************************************************"
    echo "********************************************************************"
    echo "********************************************************************"
    echo "*****"
    echo "***** $message"
    LogToSyslog "$priority" "$message"
    ;;
  *)
    echo "????($priority)???? $message"
    LogToSyslog "warn" "PrintMessage called with an unsupported priority ($priority)"
esac
}

Usage() {
# Print user help
echo "Copyright (C) Senso-Rezo - SPKI (http://github.com/olemaire/spki)

Usage: spki <option> (<subject>) 

Available options are:
    --init                           Initialize a new Certiciate Authority.
    --server <fqdn>                  Generate a Server certificate.
    --user <email>                   Generate an User certificate.
    --verify <email,fqdn>            Verify a given certificate.
    --renew <email,fqdn> (reason)    Renew a given certificate.
    --revoke <email,fqdn> (reason)   Revoke a given certificate.
    --crl                            Generate a Certificate Revocation List.
    --info <email,fqdn,ca,crl>       Will display human readable infos on certificate/CRL
    --status                         Will give information on the SPKI status.
    --help                           Display this short help message.

Exemples:
	spki --server www.senso-rezo.org
        spki --info www.senso-rezo.org
	spki --user olivier.lemaire@senso-rezo.org
        spki --revoke ldap.senso-rezo.org
	spki --revoke www.senso-rezo.org keyCompromise
	spki --renew olivier.lemaire@senso-rezo.org
	spki --crl
        spki --info crl

"
}

## MAIN

CheckConfig
case "$1" in
  -init|--init|init)
    InitializeCA
    ;;
  -server|--server|server)
    CheckEnv
    GenerateCert "server" $2
    ;;
  -user|--user|user)
    CheckEnv
    GenerateCert "user" $2
    ;;
  -verify|--verify|verify)
    CheckEnv 
    if VerifyCert $2 ; then
      echo "Certificate for $2 is VALID"
      exit 0
    else
      echo "Certificate for $2 is INVALID"
      exit 100
    fi
    ;;
  -renew|--renew|renew)
    CheckEnv
    echo "renew $2 (reason $3) - Not Implemented yet"
    ;;
  -revoke|--revoke|revoke)
    CheckEnv
    RevokeCert $2 $3
    ;;
  -crl|--crl|crl)
    CheckEnv
    if GenerateCRL ; then
      echo "A new CRL has been generated"
    fi
    ;;
  -info|--info|info)
    CheckEnv
    case "$2" in
      crl)
        PrintCRLInfo 
        ;;
      "")
        PrintCAInfo
        ;;
      *)
        PrintCertInfo $2
    esac
    ;;
  -status|--status|status)
    if CheckEnv ; then
      echo "OK"
    fi
    ;;
  -h|-help|--help|help)
    Usage
    ;;
  "")
    echo "SPKI Copyright (C) Senso-Rezo - SPKI (http://github.com/olemaire/spki)"
    echo ""
    echo "Please RTFM: spki --help"
    echo ""
    ;;
  *)
    DieLogging 12 "SPKI invalid function call $1 (try --help)"
esac

# TODO:
# * deal with publication (CA cert, certs, crl) on a repository (see with OpenSSL configuration for CRL distribution)
# * reclassify most LogToSyslog "info" to "debug" - and make sure to deal with verbosity/debugmode (dropping debug by default)
# * check automated mode at startup - and die if not supported -> will reduce DieLogging 12 in tons of case $automated..
# - This Is The End
