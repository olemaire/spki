#!/bin/bash
#   SPKI -  Simple Public Key Infrastructure
#   Copyright Â© 2014 Senso-Rezo
#   All rights reserved.
#   See LICENSE file for licensing information.
#   See http://github.com/olemaire/spki for more information.

# spki - spki core util (command line)

# Default values - will be overridable by configuration file (spki.conf) - DO NOT EDIT THERE
COUNTRY="US"                     # Country Code you want to registrer the PKI to (must be 2 letter country code)
DOMAIN="senso-rezo.org"          # Domain name that will appear by default: change it by your company domain name
COMPANY="Senso-Rezo"             # Company name that will appear by default: change it by your company name
supportmail="sysadm"             # The Support Email address used for server certiciates
BITS=2048                        # Random bits used (recommended values: 1024 >= BITS =< 4096)
CACERT_DAYS=7306                 # Certificate Authority certificate will be valid for this period (just over 20 years...)
SERVER_DAYS=3653                 # Server certificate will be issued (new, renewed) for this period (just over 10 years...)
USER_DAYS=396                    # User certificates will be issued (new, renewed) for this period (just over 13 months...)
CRL_DAYS=31                      # Days between each CRL is due (a new CRL *MUST* be regenerated before this delay)

# user/context automation mode - may be overrided by user configuration file (spki.conf) - DO NOT EDIT THERE
automated="yes"                          # Define if SPKI must be full automated or not (yes/no)
debugmode="no"                           # Activate/Desactivate the debug mode (yes/no) - default no
specificlogfile="no"                     # Activate a specific logfile (yes/no) - default no (using syslog)
logtofile="/dev/null"                # If logfile is activated (specific logfile instated of syslog), then which is the log file to use


# Non overridable values - cannot be changed by user's configuration file
# SPKI internal variables - should not be changed unless you perfectly know what your are doing (and prepare to debug)
dir=$(cd `dirname $0` && pwd)            # directory where the SPKI is to be run
SPKI_CONFIG="$dir/spki.conf"             # SPKI configuration file - if you want to override default builtin values
CONFIG_CA="$dir/private/root_ca.conf"    # where the Certificate Authority OpenSSL configuration file is stored
loggertag="SPKI"                         # Tag used for messages within syslog
loggerchan="daemon"                      # Facitily used for messages within syslog
ESC_SEQ="\x1b["                          # Color codes, used for PrintMessage() and some informations:
COL_RESET=$ESC_SEQ"39;49;00m"            # - RED for Errors/Alerts/Emergs - and INVALID certificates 
COL_RED=$ESC_SEQ"31;01m"                 # - YELLOW for Warnings and Unknown (but still not error)
COL_GREEN=$ESC_SEQ"32;01m"               # - GREEN if everything is OK, certificate is VALID
COL_YELLOW=$ESC_SEQ"33;01m"              # 

# SPKI known types of certificates and related extensions
# Known SPKI types: 
# - server
spki_type_server="spki_type_server_cert"
spki_type_server_extensions="serverAuth,clientAuth,msSGC,nsSGC"
# - user
spki_type_user="spki_type_user_cert"
spki_type_user_extensions="clientAuth,emailProtection"


## FUNCTIONS
CheckEnv() {
# Check if the CA is operational
if [ ! -f $dir/certs/ca.pem ] || [ ! -f $dir/private/ca.key ] || [ ! -f $CONFIG_CA ] || [ ! -f $dir/crl/current_crl.pem ] || [ ! -f $dir/datas/index ]; then
  PrintMessage "emerg" "Check CA Environment reveal no pre-existing or broken CA"
  echo "***** Please run '$0 --initialize' to initalize a new Certificate Authority"
  DieLogging 11 "The Certificate Authority has not (yet) been Initialized"
fi

# Check that the CRL is not Expired, and if so, regenerate one - see ticket #18
# -> verifying the CA certificate
# -> if verification return message ends by "CRL has expired", we need to regenerate a new CRL -> let's do it!
# -> verifying the CA certificate again, with the assurance the CRL is ok now.
# -> if CA certificate not VALID, then the CA IS NOT OPERATIONAL (cert expired or file corrupted -> to be investigated by admins)

local result=$(openssl verify -CApath $dir/crl/ -crl_check $dir/certs/ca.pem) || DieLogging 67 "CheckEnv cannot verify the CA certificate!!" 
local regexexpired=".*CRL has expired"
local regexok=".*ca.pem: OK\$"

LogToSyslog "debug" "CheckEnv: CRL Expiry verification"
if [[ $result =~ $regexexpired ]]; then
  LogToSyslog "alert" "CheckEnv detected an Expired CRL"
  LogToSyslog "alert" "CheckEnv regenerating a new CRL" 
  openssl ca -gencrl -config $CONFIG_CA -crldays $CRL_DAYS -out $dir/crl/current_crl.pem > /dev/null 2>&1 || DieLogging 66 "CheckEnv cannot generate a new CRL"
  /usr/bin/c_rehash $dir/crl > /dev/null 2>&1 || DieLogging 126 "GenerateCRL cannot rehash its directory"
  LogToSyslog "debug" "A new CRL has been generated and CRL directory rehashed"
  LogToSyslog "alert" "CheckEnv has regenerated a new CRL" 
else
  LogToSyslog "debug" "CheckEnv: CRL Expiry verification is OK"
fi

LogToSyslog "debug" "CheckEnv: CRL Expiry verification"
result=$(openssl verify -CApath $dir/crl/ -crl_check $dir/certs/ca.pem) || DieLogging 67 "CheckEnv cannot verify the CA certificate!!" 
if [[ $result =~ $regexok ]]; then
  LogToSyslog "debug" "CheckEnv: CA Certificate validy verification is OK"
else
  PrintMessage "emerg" "The Certificate Authority root certificate is not (anymore?) valid!!!"
  echo "***** ADMNINISTRATIVE ACTION REQUIRED"
  DieLogging 67 "The Certificate Authority is not operational"
fi

# Making sure the OpenSSL Index database is update with expired certificates - see #19
LogToSyslog "debug" "CheckEnv: Openssl updating its index database"
openssl ca -config $CONFIG_CA -updatedb > /dev/null 2>&1 || DieLogging 66 "CheckEnv cannot force OpenSSL to update its index database (pruning)"

}

CheckConfig() {
# Check if config is consistent - done at each startup anyway
if [ -f $SPKI_CONFIG ]; then
  LogToSyslog "debug" "CheckConfig: configuration file found, will so parse it and override builtin values..."
  ParseConfigFile
else
  LogToSyslog "debug" "CheckConfig: no configuration file found, using default builtin values"
fi

}

ParseConfigFile() {
# Will parse local configuration file and export values if in accepted list - else log warn
LogToSyslog "debug" "ParseConfigFile: parsing local configuration file $SPKI_CONFIG..."
shopt -s extglob
while IFS='= ' read lhs rhs
do
  if [[ ! $lhs =~ ^\ *# && -n $lhs ]]; then
    rhs="${rhs%%\#*}"    # Del in line right comments
    rhs="${rhs%%*( )}"   # Del trailing spaces
    rhs="${rhs%\"*}"     # Del opening string quotes 
    rhs="${rhs#\"*}"     # Del closing string quotes 
    case "$lhs" in
      COUNTRY)
        COUNTRY="$rhs"
        ## Should have a check on lenght (2 chars max)
        LogToSyslog "debug" "ParseConfigFile: value ($lhs) overrided with content ($rhs)"
        ;;
      DOMAIN)
        DOMAIN="$rhs"
        LogToSyslog "debug" "ParseConfigFile: value ($lhs) overrided with content ($rhs)"
        ;;
      COMPANY)
        COMPANY="$rhs"
        LogToSyslog "debug" "ParseConfigFile: value ($lhs) overrided with content ($rhs)"
        ;;
      supportmail)
        supportmail="$rhs"
        LogToSyslog "debug" "ParseConfigFile: value ($lhs) overrided with content ($rhs)"
        ;;
      BITS)
        if [ "$rhs" -lt 1024 ]; then
          DieLogging 9 "ParseConfigFile: Random Bits ($lhs) must be greater than 1024!!!"
        elif [ "$rhs" -gt 4096 ]; then
          DieLogging 9 "ParseConfigFile: Random Bits ($lhs) must be not exceed 4096!!!"
        else
          BITS="$rhs"
          LogToSyslog "debug" "ParseConfigFile: $lhs overrided with legal value ($rhs)"
        fi
        ;;
      CACERT_DAYS)
        CACERT_DAYS="$rhs"
        LogToSyslog "debug" "ParseConfigFile: value ($lhs) overrided with content ($rhs)"
        ;;
      SERVER_DAYS)
        SERVER_DAYS="$rhs"
        ## Should be -lt CACERT_DAYS
        LogToSyslog "debug" "ParseConfigFile: value ($lhs) overrided with content ($rhs)"
        ;;
      USER_DAYS)
        USER_DAYS="$rhs"
        ## Should be -lt CACERT_DAYS
        LogToSyslog "debug" "ParseConfigFile: value ($lhs) overrided with content ($rhs)"
        ;;
      CRL_DAYS)
        CRL_DAYS="$rhs"
        ## Should be -lt CACERT_DAYS - and all other SERVER/USER_DAYS too
        LogToSyslog "debug" "ParseConfigFile: value ($lhs) overrided with content ($rhs)"
        ;;
      automated)
        case "$rhs" in
          yes|on|no|not|off)
            automated="$rhs"
            LogToSyslog "debug" "ParseConfigFile: $lhs overrided with legal value ($rhs)"
            ;;
          *)
            DieLogging 9 "ParseConfigFile: $lhs not supported ($rhs)!!!"
        esac
        ;;
      debugmode)
        case "$rhs" in
          yes|no)
            debugmode="$rhs" 
            LogToSyslog "debug" "ParseConfigFile: $lhs overrided with legal value ($rhs)"
            ;;
          *)
            DieLogging 9 "ParseConfigFile: $lhs not supported ($rhs)!!!"
        esac
        ;;
      specificlogfile)
        case "$rhs" in
          yes|no)
            LogToSyslog "debug" "ParseConfigFile: $lhs overrided with legal value ($rhs)"
            specificlogfile="$rhs" # done after LogToSyslog as logtofile not yet tested ok (so better safe than sorry)
            ;;
          *)
            DieLogging 9 "ParseConfigFile: $lhs not supported ($rhs)!!!"
        esac
        ;;
      logtofile)
        if [ "$specificlogfile" == "yes" ]; then
          if [ -w $rhs ]; then
            logtofile="$rhs"
            LogToSyslog "debug" "ParseConfigFile: $lhs overrided with legal value ($rhs)"
          else
            $(touch $rhs > /dev/null 2>&1) ; local testtouch=$?
            if [ "$testtouch" -eq "0" ]; then
              logtofile="$rhs"
              LogToSyslog "debug" "ParseConfigFile: $lhs overrided with legal value ($rhs)"
            else
              DieLogging 9 "ParseConfig: $lhs not supported as ($rhs) not writable"
            fi 
          fi
        else
          LogToSyslog "debug" "ParseConfigFile: ignoring logtofile value as specificlogfile is positionned at no"
        fi 
        ;;
      *)
        LogToSyslog "warn" "ParseConfigFile: not supported value ($lhs) - typo error? - ignoring"
    esac
  fi
done < $SPKI_CONFIG
}


CheckIfExist() {
# Check it the subject already exists - return 0 if exists, 1 if not
local subject=$1
if [ ! -f $dir/certs/$subject.pem ]; then
  return 1
else
  return 0
fi
}


InitializeCA() {
# Initialize the PKI(CA) elements - warning as purge any existing previous elements
LogToSyslog "alert" "Initialization of a Certificate Authority triggered"
if [ -f $dir/private/ca.key ] || [ -f $dir/certs/ca.pem ]; then
  LogToSyslog "alert" "A existing Certificate Environment is detected while asking to Initialize a new one"
  PrintMessage "alert" "ALERT: all previous existing certificates will be erased!" ;
  echo -e -n "Are your sure you want to continue (y/n)? " ;
  read i ;
  [ "$i" = "y" ] || DieLogging 10 "InializeCA was canceled by user";
fi
PrintMessage "alert" "Initializing Root Certificate Authority for $COMPANY:"

LogToSyslog "debug" "cleaning existing datas..."
  rm -rf $dir/{certs,csr,datas,keys,private,crl} || DieLogging 126 "InitializeCA cannot delete existing datas"
  mkdir $dir/{certs,csr,datas,keys,private,crl} || DieLogging 126 "InitializeCA cannot create base directory structure"

LogToSyslog "debug" "Generating the Certificate Authority signing environment..."
  sleep 1 
  case "$automated" in
    yes|on)
      PrintMessage "info" "Automated mode is ON..."
      PrintMessage "info" "Initializing Random Bits..."
      openssl rand $BITS > $dir/datas/random_bits > /dev/null 2>&1 || DieLogging 126 "InitializeCA cannot create Random Bits"
      PrintMessage "info" "Generating the Certificate Authority private Key..."
      openssl genrsa -out $dir/private/ca.key $BITS -rand $dir/datas/random_bits > /dev/null 2>&1 || DieLogging 66 "InitializeCA cannot generate Certificate Authority private Key"
      ;;
    no|not|off)
      PrintMessage "info" "Automated mode is OFF..."
      openssl rand $BITS > $dir/datas/random_bits || DieLogging 126 "InitializeCA cannot create Random Bits"
      PrintMessage "info" "Generating the Certificate Authority private Key..."
      openssl genrsa -des3 -out $dir/private/ca.key $BITS -rand $dir/datas/random_bits || DieLogging 66 "InitializeCA cannot generate Certificate Authority private Key"
      ;;
    *)
    DieLogging 12 "InitializeCA called in an unsupported automated mode ($automated)"
  esac
  chmod 600 $dir/private/ca.key || DieLogging 126 "InitializeCA cannot chmod the Certificate Authority private Key"

LogToSyslog "debug" "Generating Certificate Authority OpenSSL configuration file..."
  /bin/cat > $CONFIG_CA <<EOT || DieLogging 126 "InitializeCA cannot create Configuration file"
[ ca ]
default_ca              = default_CA                                        # The default CA section
[ default_CA ]
dir                     = $dir                                              # Top directory
certs                   = $dir/certs                                        # Certificate repository
new_certs_dir           = $dir/datas/certs                                  # Certificate archive
database                = $dir/datas/index                                  # CA database
unique_subject          = no                                                # Require unique subject
serial                  = $dir/datas/serial_cert                            # Cert number file
crlnumber               = $dir/datas/serial_crl                             # CRL number file
RANDFILE                = $dir/datas/random_bits
certificate             = $dir/certs/ca.pem                                 # The CA certificate
private_key             = $dir/private/ca.key                               # The CA private key
default_days            = $SERVER_DAYS                                      # How long to certify for
default_crl_days        = $CRL_DAYS                                         # How long a CRL is due 
default_md              = sha1                                              # MD to use
preserve                = no                                                # Keep passed DN ordering
name_opt                = multiline,-esc_msb,utf8                           # Display UTF-8 characters
x509_extensions         = spki_type_server_cert                             # default x509v3 extensions used
policy                  = policy_anything
[ policy_match ]
countryName             = match
stateOrProvinceName     = match
organizationName        = match
organizationalUnitName  = optional
commonName              = supplied
emailAddress            = optional
[ policy_anything ]
countryName             = optional
stateOrProvinceName     = optional
localityName            = optional
organizationName        = optional
organizationalUnitName  = optional
commonName              = supplied
emailAddress            = optional
[ spki_type_server_cert ]
subjectKeyIdentifier            = hash
authorityKeyIdentifier          = keyid:always
extendedKeyUsage                = $spki_type_server_extensions
basicConstraints                = critical,CA:false
nsComment                       = "SPKI $COMPANY Server Certificate"
[ v3_ca ]
basicConstraints                = critical,CA:true
subjectKeyIdentifier            = hash
keyUsage                        = critical, keyCertSign, cRLSign
authorityKeyIdentifier          = keyid:always,issuer:always
nsCertType                      = sslCA, emailCA, objCA
nsComment                       = "SPKI $COMPANY Root CA Certificate"
# subjectAltName                = email:copy
[ v3_req ]
nsCertType                      = objsign,email,server
[ user_policy ]
commonName                      = supplied
emailAddress                    = supplied
[ spki_type_user_cert ]
subjectAltName                  = email:copy
basicConstraints                = critical,CA:false
authorityKeyIdentifier          = keyid:always
extendedKeyUsage                = $spki_type_user_extensions
nsComment                       = "SPKI $COMPANY User Certificate"
EOT
case "$automated" in
  yes|on)
    /bin/cat >> $CONFIG_CA <<EOT || DieLogging 126 "InitializeCA cannot create Configuration file - req part"
[ req ]
default_bits                    = $BITS
dir                             = $dir
default_keyfile                 = $dir/private/ca.key
utf8                            = yes                                      # Input are dealt as UTF-8
prompt                          = no                                       # Do not prompt for DN while managing CSR - because full automated way
distinguished_name              = req_distinguished_name
x509_extensions                 = v3_ca
string_mask                     = utf8only                                 # Emit UTF-8 Strings
req_extensions                  = v3_req
[ req_distinguished_name ]
countryName                     = "$COUNTRY"
organizationName                = "$COMPANY"
organizationalUnitName          = "$COMPANY Security Services"
commonName                      = "$COMPANY Root CA"
EOT
    ;;
  no|not|off)
    /bin/cat >> $CONFIG_CA <<EOT || DieLogging 126 "InitializeCA cannot create Configuration file - req part"
[ req ]
default_bits                    = $BITS
dir                             = $dir
default_keyfile                 = $dir/private/ca.key
utf8                            = yes                                      # Input are dealt as UTF-8
distinguished_name              = req_distinguished_name
x509_extensions                 = v3_ca
string_mask                     = utf8only                                 # Emit UTF-8 Strings
req_extensions                  = v3_req
[ req_distinguished_name ]
countryName                     = Country Name (2 letter code)
countryName_default             = "$COUNTRY"
countryName_min                 = 2
countryName_max                 = 2
0.organizationName              = Organization Name
0.organizationName_default      = "$COMPANY"
organizationalUnitName          = Certificate Division
organizationalUnitName_default  = "$COMPANY Security Team"
commonName                      = CA Name
commonName_default              = "$COMPANY Root CA"
commonName_max                  = 64
EOT
    ;;
  *)
  DieLogging 12  "InitializeCA called in an unsupported automated mode ($automated)"
esac

PrintMessage "info" "Self-signing the Certificate Authority Certificate..."
  openssl req -new -x509 -config $CONFIG_CA -days $CACERT_DAYS -key $dir/private/ca.key -out $dir/certs/ca.pem || DieLogging 66 "InitializeCA cannot Self-sign Certificate Authority Certificate"

PrintMessage "info" "Initializing user environment (directories and indexes)..."
  if [ ! -d $dir/datas/certs ]; then
    mkdir -p $dir/datas/certs || DieLogging 126 "InitializeCA Cannot create $dir/datas/certs directory"
  fi
  if [ ! -f $dir/datas/serial_cert ]; then
    echo '01' > $dir/datas/serial_cert || DieLogging 126 "InitializeCA cannot create $dir/datas/serial_cert file"
  fi
  if [ ! -f $dir/datas/serial_crl ]; then
    echo '01' > $dir/datas/serial_crl || DieLogging 126 "InitializeCA cannot create $dir/datas/serial_crl file"
  fi
  if [ ! -f $dir/datas/index ]; then
    /bin/cp /dev/null $dir/datas/index || DieLogging 126 "InitializeCA cannot create $dir/datas/index file"
  fi

LogToSyslog "debug" "Issuing the first Certificate Revocation List"
  /bin/cp $dir/certs/ca.pem $dir/crl/ca.pem || DieLogging 126 "InitializeCA cannot copy CA certificate to CRL directory"
  #GenerateCRL || DieLogging 126 "InitializeCA cannot generate the first CRL"
  openssl ca -gencrl -config $CONFIG_CA -crldays $CRL_DAYS -out $dir/crl/current_crl.pem > /dev/null 2>&1 || DieLogging 66 "CheckEnv cannot generate a new CRL"
  /usr/bin/c_rehash $dir/crl > /dev/null 2>&1 || DieLogging 126 "GenerateCRL cannot rehash its directory"

PrintMessage "alert" "$COMPANY Root Certificate Authority is initialized."
PrintMessage "info" "SPKI ready for service" ; echo ""
InfoOnCA
}

IssueCert() {
# Issue Certificate with type $1 for subject $2
local certtype=$1
local subject=$2

CheckEnv # Start making sure the PKI environment is OK

CheckCertType $certtype || DieLogging 12 "IssueCert cannot issue a certificate of an unsupported type ($certtype)"

LogToSyslog "debug" "User ask to Issue a type $certtype certificate for subject $subject - checking"
case "$certtype" in
  server)
    CheckSubject "fqdn" "$subject" || DieLogging 12 "GenerateCert cannot generate a $certtype certificate for invalid FQDN ($subject)"
  ;;
  user)
    CheckSubject "email" "$subject" || DieLogging 12 "GenerateCert cannot generate a $certtype certificate for invalid EMAIL ($subject)"
  ;;
  *)
    DieLogging 12 "IssueCert asked for an Unknown type of certificate asked ($certtype)"
esac

GenerateCert "$certtype" "$subject"
}

CheckCertType() {
# Check if $1 (type) is a valid/supported type (server or user) - if ok return 0, else return 1
local checktype=$1

case "$checktype" in
  server|user)
    LogToSyslog "debug" "CheckCertType checked a supported Certificate Type ($checktype) - OK"
    return 0
    ;;
  *)
    LogToSyslog "debug" "CheckCertType checked an unsupported Certificate Type ($checktype)"
    return 1
esac
}

CheckSubject() {
# Check if $2 (subject) is a valid subject (server fqdn or email) depending on type (server=fqdn,user=email) - if ok return 0, else return 1
local checktype=$1
local subject=$2
LogToSyslog "debug" "Checking if $subject if of type $checktype..."
case "$checktype" in
  fqdn)
    local regex="^[a-z0-9!#\$%&'*+/=?^_\`{|}~-]+(\.[a-z0-9!#$%&'*+/=?^_\`{|}~-]+)*\$" #FIXME: wildcard not supported with this regexp - review this regexp as too permissive anyway
  ;;
  email)
    local regex="^[a-z0-9!#\$%&'*+/=?^_\`{|}~-]+(\.[a-z0-9!#$%&'*+/=?^_\`{|}~-]+)*@([a-z0-9]([a-z0-9-]*[a-z0-9])?\.)+[a-z0-9]([a-z0-9-]*[a-z0-9])?\$" #FIXME: review this regexp as seems too permissive
  ;;
  *)
    DieLogging 12 "Illegal function call: CheckSubject with type $checktype"
esac
if [[ $subject =~ $regex ]]; then
  return 0
else
  return 1
fi
}

GenerateOpenSSLConf() {
# Will generate adequate OpenSSL configuration file for signing
local conftype=$1
local subject=$2
LogToSyslog "debug" "Generating OpenSSL $conftype config file for subject $subject..."
case "$conftype" in
  server)
    local certreq="spki_type_server"
    local commonname="Common Name (ex:ldap.$DOMAIN)"
    local emailaddress="Server Administrator email address"
    local emailaddressdefault="$supportmail@$DOMAIN"
    local extendedkeyusage="serverAuth, clientAuth"
    local nscerttype="server"
    ;;
  user)
    local certreq="spki_type_user"
    local commonname="Common Name (ex: john.doe@$DOMAIN)"
    local emailaddress="User email address"
    local emailaddressdefault="$subject"
    local extendedkeyusage="clientAuth"
    local nscerttype="client,email"
    ;;
  *)
    DieLogging 12 "Illegal function call: GenerateOpenSSLConf with type $conftype"
esac

local OPENSSL_CONFIG="$dir/csr/$subject.conf"

case "$automated" in
  yes|on)
    /bin/cat > $OPENSSL_CONFIG <<EOT || DieLogging 126 "GenerateOpenSSLConf cannot create - req part"
# SPKI auto-generated OpenSSL configuration file for Certificate Signing Request
# CSR to ask a certificate of type $conftype for $subject
[ req ]
default_bits          = $BITS
default_keyfile       = $dir/keys/$subject.key
default_md            = sha1
utf8                  = yes
prompt                = no                                    # do not prompt for DN validation - because full automated way
distinguished_name    = req_distinguished_name
x509_extension        = $certreq
string_mask           = utf8only

[ req_distinguished_name ]
countryName             = "$COUNTRY"
organizationName        = "$COMPANY"
organizationalUnitName  = "Operational Unit"
commonName              = $subject
emailAddress            = $emailaddressdefault

EOT
    ;;
  no|not|off)
    /bin/cat > $OPENSSL_CONFIG <<EOT || DieLogging 126 "GenerateOpenSSLConf cannot create - req part"
[ req ]
default_bits          = $BITS
default_keyfile       = $dir/keys/$subject.key
default_md            = sha1
utf8                  = yes
distinguished_name    = req_distinguished_name
x509_extension        = $certreq
string_mask           = utf8only

[ req_distinguished_name ]
countryName                      = Country Name (2 letter code)
countryName_default              = "$COUNTRY"
countryName_min                  = 2
countryName_max                  = 2
organizationName                 = Organization Name
organizationName_default         = "$COMPANY"
organizationalUnitName           = Certificate Organisation
organizationalUnitName_default   = "$COMPANY Security Team"
commonName                       = "$commonname"
commonName_default               = $subject
commonName_max                   = 64
emailAddress                     = "$emailaddress"
emailAddress_default             = "$emailaddressdefault"
emailAddress_max                 = 64

EOT
    ;;
  *)
  DieLogging 12 "GenerateOpenSSLConf called in an unsupported automated mode ($automated)"
esac

cat >> $OPENSSL_CONFIG <<EOT || DieLogging 126 "GenerateOpenSSLConf cannot create Configuration file for $subject"
[ $certreq ]
basicConstraints      = critical, CA:false
subjectKeyIdentifier  = hash
keyUsage              = digitalSignature, keyEncipherment
extendedKeyUsage      = $extendedkeyusage
nsCertType            = $nscerttype
# - This Is The End
EOT

}

GenerateCert() {
# Will generate a server of type "type" for subject "$2"
local certtype=$1
local subject=$2

# This Check ash to be kept - unless we want to be able to re-sign a CA (renewal) - not inplemented so far.
case "$subject" in
  ca|crl)
    DieLogging 15 "GeneratCert: Illegal Operation for a protected subject ($subject)"
    ;;
  *)
    LogToSyslog "debug" "User asked to Generate a certificate for subject $subject with type $certtype"
esac

# Refuse to generate a certificate for an already existing subject
if CheckIfExist $subject ; then
  DieLogging 14 "GenerateCert: Trying to generate a $certtype certificate which already exists ($subject)"
fi

case "$certtype" in
  server)
    CheckSubject "fqdn" "$subject" || DieLogging 12 "GenerateCert cannot generate a certificate for invalid FQDN ($subject)" #DieLogging should not be needed as called by IssueCert
    GenerateOpenSSLConf "server" "$subject" 
    local certdays=$SERVER_DAYS
    local extensions="spki_type_server_cert"
  ;;
  user)
    CheckSubject "email" "$subject" || DieLogging 12 "GenerateCert cannot generate a certificate for invalid EMAIL ($subject)" #DieLogging shoud not be needed as called by IssueCert
    GenerateOpenSSLConf "user" "$subject" 
    local certdays=$USER_DAYS
    local extensions="spki_type_user_cert"
  ;;
  *)
    DieLogging 12 "GenerateCert asked for an Unknown type of certificate asked ($certtype)"
esac
LogToSyslog "debug" "Let's generate a $certtype certificate for user $subject"
LogToSyslog "debug" "Generating keys for subject $subject..." 
  case "$automated" in
    yes|on)
      openssl genrsa -out $dir/keys/$subject.key $BITS > /dev/null 2>&1 || DieLogging 66 "GenerateCert cannot generate key for $subject"
      ;;
    no|not|off)
      echo -e -n " |----> Protect key with a passphrase (y/n)? : [n] "
      read keyboard
      if [ "$keyboard" == "y" -o "$keyboard" == "Y" ]; then
        openssl genrsa -des3 -out $dir/keys/$subject.key $BITS || DieLogging 66 "GenerateCert cannot generate key for $subject"
      else
        openssl genrsa -out $dir/keys/$subject.key $BITS || DieLogging 66 "GenerateCert cannot generate key for $subject"
      fi
     ;;
    *)
    DieLogging 12 "GenerateCert called in an unsupported automated mode ($automated)"
  esac
LogToSyslog "debug" "Generating CSR for subject $subject..."
  openssl req -new -config $dir/csr/$subject.conf -key $dir/keys/$subject.key -out $dir/csr/$subject.csr || DieLogging 66 "GenerateCert cannot generate a CSR for $subject"
LogToSyslog "debug" "Asking the CA to sign the certificate for $subject..."
  case "$automated" in
    yes|on)
      LogToSyslog "debug" "-> automated mode is on..."
      openssl ca -batch -config $CONFIG_CA -days $certdays -extensions $extensions -out $dir/certs/$subject.txt -infiles $dir/csr/$subject.csr > /dev/null 2>&1 || DieLogging 66 "GenerateCert sign the submited CSR for subject $subject"
      ;;
    no|not|off)
      LogToSyslog "debug" "-> automated mode is off..."
      openssl ca -batch -config $CONFIG_CA -days $certdays -extensions $extensions -out $dir/certs/$subject.txt -infiles $dir/csr/$subject.csr || DieLogging 66 "GenerateCert sign the submited CSR for subject $subject"
      ;;
    *)
    DieLogging 12 "GenerateCert called in an unsupported automated mode ($automated)"
  esac
LogToSyslog "debug" "Extracting certificate for subject $subject..."
  /usr/bin/perl -n -e 'm/BEGIN CERTIFICATE/ && do {$$seen=1}; $$seen && print;' < $dir/certs/$subject.txt > $dir/certs/$subject.pem || DieLogging 126 "GenerateCert cannot extract certificate for subject $subject"
  rm $dir/certs/$subject.txt || DieLogging 126 "GenerateCert cannot remove (not needed anymore) certificate text file for $subject" 
LogToSyslog "debug" "Verifying certificate for $subject..."
  VerifyCert $subject || DieLogging 126 "GenerateCert certificate verification failed (UNKNOWN, so INVALID) for subject $subject"
PrintMessage "info" "Certificate ($certtype) generated for $subject:"
PrintMessage "info" " - CA certificate: $dir/certs/ca.pem"
PrintMessage "info" " - Subject certificate: $dir/certs/$subject.pem"
PrintMessage "info" " - Subject private key: $dir/keys/$subject.key"
PrintMessage "info" "Have a nice day."
}

GenerateCRL() {
# Will generate a new CRL

CheckEnv # Start making sure the PKI environment is OK

case "$automated" in
  yes|on)
    LogToSyslog "debug" "GenerateCRL asked to generate a new CRL"
    openssl ca -gencrl -config $CONFIG_CA -crldays $CRL_DAYS -out $dir/crl/current_crl.pem > /dev/null 2>&1 || DieLogging 66 "GenerateCRL cannot generate a new CRL"
    ;;
  no|not|off)
    PrintMessage "info" "Generating a new CRL..."
    openssl ca -gencrl -config $CONFIG_CA -crldays $CRL_DAYS -out $dir/crl/current_crl.pem || DieLogging 66 "GenerateCRL cannot generate a new CRL"
    ;;
  *)
  DieLogging 12 "GenerateCRL called in an unsupported automated mode ($automated)"
esac
# FIXME: seems not needed unless wanting to publish outside (which should be done at the end using a "publish" function?)
#         to be seen when crl distribution point (see #5)
#openssl crl -inform PEM -in $dir/crl/current_crl.pem -outform DER -out $dir/crl/current_crl.der || DieLogging 66 "GenerateCRL cannot encode CRL in DER format"


/usr/bin/c_rehash $dir/crl > /dev/null 2>&1 || DieLogging 126 "GenerateCRL cannot rehash its directory"

LogToSyslog "info" "A new CRL has been generated and CRL directory rehashed"

}

RenewCert() {
# Will renew the certificate for subject $1 with reason $2 (must exists - see CheckIfExists)

CheckEnv # Start making sure the PKI environment is OK

# to allow --renew (server,user) subject (reason) and --renew subject (resaon)
case "$1" in
  server|user)
    local subject=$2
    local reason=$3
    ;;
  *)
    local subject=$1
    local reason=$2
esac

# This Check as to be kept - unless we want to revoke the CA !
case "$subject" in
  ca|crl)
    DieLogging 15 "RenewCert: Illegal Operation for a protected subject ($subject)"
    ;;
  *)
    LogToSyslog "debug" "User asked to Renew a certificate for subject $subject with type $certtype"
esac

CheckIfExist $subject || DieLogging 13 "RenewCert: certificate for subject $subject does not exists!"

local certtype=$(grep x509_extension $dir/csr/$subject.conf) || DieLogging 126 "RenewCert: cannot stat the CSR configuration file for $subject certificate"
certtype=${certtype//*[[:space:]]=\ /}
certtype=${certtype#spki_type_}
case "$certtype" in
  user)
    CheckSubject "email" "$subject" || DieLogging 12 "RenewCert cannot renew a $certtype certificate for invalid EMAIL ($subject)"
    local certdays=$USER_DAYS
    local extensions="spki_type_user_cert"
    ;;
  server)
    CheckSubject "fqdn" "$subject" || DieLogging 12 "RenewCert cannot renew a $certtype certificate for invalid FQDN ($subject)"
    local certdays=$SERVER_DAYS
    local extensions="spki_type_server_cert"
    ;;
  *)
    local certtypestring="UNKNOWN certificate"
    local certcapacities="UNKNOWN"
    DieLogging 12 "RenewCert asked to renew an Unknown type of certificate ($certtype) for $subject"
esac

if [ ! -f $dir/csr/$subject.csr ]; then
  DieLogging 126 "RenewCert: cannot find the CSR for $subject certificate"
fi

case "$reason" in
  unspecified|keyCompromise|CACompromise|affiliationChanged|superseded|cessationOfOperation|certificateHold)
    LogToSyslog "debug" "RenewCert: is called to renew certificate for subject $subjet with reason $reason"
    local renewal_reason=$reason
    ;;
  "")
    LogToSyslog "debug" "RevokeCert: is called to revoke certificate for subject $subject with no reason, so defaulting to superseded)"
    local renewal_reason="superseded"
    ;;
  *)
    LogToSyslog "warn" "RevokeCert: is called to revoke certificate for subject $subject with unknown reason ($reason), defaulting to superseded"
    local renewal_reason="superseded"
esac

$(VerifyCert $subject) ; local verifycert=$?
case "$verifycert" in
  0)
    # Certificate to renew is valid -> revoking it first -> then renew cert
    PrintMessage "info" "Renewing Certificate (type: $certtype) for $subject with reason $renewal_reason:"
    PrintMessage "info" " - a VALID certificate already exits, so revoking it first (reason = $renewal_reason)"
    case "$automated" in
      yes|on)
        LogToSyslog "debug" "-> automated mode is on..."
        openssl ca -revoke $dir/certs/$subject.pem -config $CONFIG_CA -crl_reason $renewal_reason > /dev/null 2>&1 || DieLogging 66 "RenewCert: unable to revoke certificate for subject $subject"
        PrintMessage "info" " - Certificate for subject $subject has been revoked for reason $renewal_reason."
        GenerateCRL || DieLogging 126 "RenewCert cannot generate a CRL (automated mode is $automated)"
        openssl ca -batch -config $CONFIG_CA -days $certdays -extensions $extensions -out $dir/certs/$subject.txt -infiles $dir/csr/$subject.csr > /dev/null 2>&1 || DieLogging 66 "RenewCert sign the original CSR for subject $subject"
        PrintMessage "info" " - Generating a new certificate (type: $certtype) for $subject..."
        ;;
      no|not|off)
        LogToSyslog "debug" "-> automated mode is off..."
        openssl ca -revoke $dir/certs/$subject.pem -config $CONFIG_CA -crl_reason $renewal_reason || DieLogging 66 "RenewCert: unable to revoke certificate for subject $subject"
        PrintMessage "info" " - Certificate for subject $subject has been revoked for reason $renewal_reason."
        PrintMessage "info" " - You should think about generating a new CRL..."
        openssl ca -batch -config $CONFIG_CA -days $certdays -extensions $extensions -out $dir/certs/$subject.txt -infiles $dir/csr/$subject.csr || DieLogging 66 "RenewCert sign the original CSR for subject $subject"
        PrintMessage "info" " - Generating a new certificate (type: $certtype) for $subject..."
        ;;
      *)
        DieLogging 12 "RenewCert called in an unsupported automated mode ($automated)" # Should not arrive as CheckConfig is already done
    esac
    LogToSyslog "debug" "Extracting certificate for subject $subject..."
    /usr/bin/perl -n -e 'm/BEGIN CERTIFICATE/ && do {$$seen=1}; $$seen && print;' < $dir/certs/$subject.txt > $dir/certs/$subject.pem || DieLogging 126 "RenewCert cannot extract certificate for subject $subject"
    rm $dir/certs/$subject.txt || DieLogging 126 "RenewCert cannot remove (not needed anymore) certificate text file for $subject"
    LogToSyslog "debug" "Verifying certificate for $subject..."
    VerifyCert $subject || DieLogging 126 "RenewCert certificate verification failed (UNKNOWN, so INVALID) for subject $subject"
    PrintMessage "info" " - A New Certificate ($certtype) generated for $subject at:"
    PrintMessage "info" " - $dir/certs/$subject.pem"
    PrintMessage "info" "Have a nice day."
    return 0
    ;;
 101)
    # Certificate to renew has already been revoked -> renewing it directly
    PrintMessage "info" "Renewing Certificate (type: $certtype) for $subject with reason $renewal_reason:"
    PrintMessage "info" " - a certificate for $subject have already been revoked, so no reason to revoke now"
    case "$automated" in
      yes|on)
        LogToSyslog "debug" "-> automated mode is on..."
        openssl ca -batch -config $CONFIG_CA -days $certdays -extensions $extensions -out $dir/certs/$subject.txt -infiles $dir/csr/$subject.csr > /dev/null 2>&1 || DieLogging 66 "RenewCert sign the original CSR for subject $subject"
        PrintMessage "info" " - Generating a new certificate (type: $certtype) for $subject..."
        ;;
      no|not|off)
        LogToSyslog "debug" "-> automated mode is off..."
        openssl ca -batch -config $CONFIG_CA -days $certdays -extensions $extensions -out $dir/certs/$subject.txt -infiles $dir/csr/$subject.csr || DieLogging 66 "RenewCert sign the original CSR for subject $subject"
        PrintMessage "info" " - Generating a new certificate (type: $certtype) for $subject..."
        ;;
      *)
        DieLogging 12 "RenewCert called in an unsupported automated mode ($automated)" # Should not arrive as CheckConfig is already done
    esac
    LogToSyslog "debug" "Extracting certificate for subject $subject..."
    /usr/bin/perl -n -e 'm/BEGIN CERTIFICATE/ && do {$$seen=1}; $$seen && print;' < $dir/certs/$subject.txt > $dir/certs/$subject.pem || DieLogging 126 "RenewCert cannot extract certificate for subject $subject"
    rm $dir/certs/$subject.txt || DieLogging 126 "RenewCert cannot remove (not needed anymore) certificate text file for $subject"
    LogToSyslog "debug" "Verifying certificate for $subject..."
    VerifyCert $subject || DieLogging 126 "RenewCert certificate verification failed (UNKNOWN, so INVALID) for subject $subject"
    PrintMessage "info" " - A New Certificate ($certtype) generated for $subject at:"
    PrintMessage "info" " - $dir/certs/$subject.pem"
    PrintMessage "info" "Have a nice day."
    return 0
    ;;
 102)
    # Certificate to renew has already expired -> revoking it to make sure, then renewing
    PrintMessage "info" "Renewing Certificate (type: $certtype) for $subject with reason $renewal_reason:"
    PrintMessage "info" " - a EXPIRED certificate already exits, so revoking it first (reason = $renewal_reason)"
    case "$automated" in
      yes|on)
        LogToSyslog "debug" "-> automated mode is on..."
        openssl ca -revoke $dir/certs/$subject.pem -config $CONFIG_CA -crl_reason $renewal_reason > /dev/null 2>&1 || DieLogging 66 "RenewCert: unable to revoke certificate for subject $subject"
        PrintMessage "info" " - Certificate for subject $subject has been revoked for reason $renewal_reason."
        GenerateCRL || DieLogging 126 "RenewCert cannot generate a CRL (automated mode is $automated)"
        openssl ca -batch -config $CONFIG_CA -days $certdays -extensions $extensions -out $dir/certs/$subject.txt -infiles $dir/csr/$subject.csr > /dev/null 2>&1 || DieLogging 66 "RenewCert sign the original CSR for subject $subject"
        PrintMessage "info" " - Generating a new certificate (type: $certtype) for $subject..."
        ;;
      no|not|off)
        LogToSyslog "debug" "-> automated mode is off..."
        openssl ca -revoke $dir/certs/$subject.pem -config $CONFIG_CA -crl_reason $renewal_reason || DieLogging 66 "RenewCert: unable to revoke certificate for subject $subject"
        PrintMessage "info" " - Certificate for subject $subject has been revoked for reason $renewal_reason."
        PrintMessage "info" " - You should think about generating a new CRL..."
        openssl ca -batch -config $CONFIG_CA -days $certdays -extensions $extensions -out $dir/certs/$subject.txt -infiles $dir/csr/$subject.csr || DieLogging 66 "RenewCert sign the original CSR for subject $subject"
        PrintMessage "info" " - Generating a new certificate (type: $certtype) for $subject..."
        ;;
      *)
        DieLogging 12 "RenewCert called in an unsupported automated mode ($automated)" # Should not arrive as CheckConfig is already done
    esac
    LogToSyslog "debug" "Extracting certificate for subject $subject..."
    /usr/bin/perl -n -e 'm/BEGIN CERTIFICATE/ && do {$$seen=1}; $$seen && print;' < $dir/certs/$subject.txt > $dir/certs/$subject.pem || DieLogging 126 "RenewCert cannot extract certificate for subject $subject"
    rm $dir/certs/$subject.txt || DieLogging 126 "RenewCert cannot remove (not needed anymore) certificate text file for $subject"
    LogToSyslog "debug" "Verifying certificate for $subject..."
    VerifyCert $subject || DieLogging 126 "RenewCert certificate verification failed (UNKNOWN, so INVALID) for subject $subject"
    PrintMessage "info" " - A New Certificate ($certtype) generated for $subject at:"
    PrintMessage "info" " - $dir/certs/$subject.pem"
    PrintMessage "info" "Have a nice day."
    return 0
    ;;
 100)
    # That means I cannot stat the certificate status -> DieLogging (to be fixed by dev) 
    DieLogging 103 "RenewCert cannot renew a certificate of Unkown status for $subject"
    ;;
   *)
    DieLogging 103 "RenewCert cannot renew certificate for $subject as cannot determine its actual certificate status -> Unknown"
    # That situation should not arise
esac

}


RevokeCert() {
# Will revoke the certificate for subject $1 (must exists - see CheckIfExists)

CheckEnv # Start making sure the PKI environment is OK

# to allow --revoke (server,user) subject - and --revoke subject
case "$1" in
  server|user)
    local subject=$2
    local reason=$3
    ;;
  *)
    local subject=$1
    local reason=$2
esac

# This Check ash to be kept - unless we want to revoke the CA !
case "$subject" in
  ca|crl)
    DieLogging 15 "RevokeCert: Illegal Operation for a protected subject ($subject)"
    ;;
  *)
    LogToSyslog "debug" "User asked to Revoke a certificate for subject $subject with type $certtype"
esac

CheckIfExist $subject || DieLogging 13 "RevokeCert: certificate for subject $subject does not exists!"

$(VerifyCert $subject) ; local verifycert=$?
case "$verifycert" in
  0|102)
    # Certif is valid (o) or expired (102), so we may revoke it
    LogToSyslog "debug" "RevokeCert: can revoke certificate for $subject as certificate is $verifycert (0= valid, 102= expired)"
    ;;
  101)
    # Certificate is already revoked -> So Die 14
    DieLogging 14 "RevokeCert: certificate for subject $subject is already revoked!"
    ;;
  100) 
   # Certificate is Unknown -> So Die 103...
    DieLogging 103 "RevokeCert: certificate for subject $subject is already status Unknown (so invalid) -> I will not revoke it!"
    ;;
  *)
   # Unknown state so die 12
   DieLogging 12 "RevokeCert: certificate for subject $subject is in Undeternined status/return code ($verifycert) - will not be able to revoke it"
   # That situation should not arise -> Illegal Function Call ?
esac

case "$reason" in
  unspecified|keyCompromise|CACompromise|affiliationChanged|superseded|cessationOfOperation|certificateHold)
    LogToSyslog "debug" "RevokeCert: is called to revoke certificate for subject $subjet with reason $reason"
    local revocation_reason=$reason
    ;;
  "")
    LogToSyslog "debug" "RevokeCert: is called to revoke certificate for subject $subject with no reason, so defaulting to unspecified)"
    local revocation_reason="unspecified"
    ;;
  *)
    LogToSyslog "warn" "RevokeCert: is called to revoke certificate for subject $subject with unknown reason ($reason), defaulting to unspecified" 
    local revocation_reason="unspecified"
esac

PrintMessage "info" "Revoking certificate for $subject (reason = $revocation_reason):"
case "$automated" in
  yes|on)
    openssl ca -revoke $dir/certs/$subject.pem -config $CONFIG_CA -crl_reason $revocation_reason > /dev/null 2>&1 || DieLogging 66 "RevokeCert: unable to revoke certificate for subject $subject"
    PrintMessage "info" " - Certificate for subject $subject has been revoked for reason $revocation_reason."
    GenerateCRL || DieLogging 126 "RevokeCert cannot generate a CRL (automated mode is $automated)"
    PrintMessage "info" " - Generating a new CRL..."
    PrintMessage "info" "Certificate for subject $subject has been revoked and a new CRL has been generated."
    ;;
  no|not|off)
    openssl ca -revoke $dir/certs/$subject.pem -config $CONFIG_CA -crl_reason $revocation_reason || DieLogging 66 "RevokeCert: unable to revoke certificate for subject $subject"
    PrintMessage "info" " - Certificate for subject $subject has been revoked for reason $revocation_reason."
    PrintMessage "info" "You should think about generate a new CRL."
    ;;
  *)
  DieLogging 12 "RevokeCert called in an unsupported automated mode ($automated)"
esac
}

VerifyCert() {
# Will verify certificate for subjet $1 (must exists - see CheckIfExist)
local subject=$1

CheckEnv # Start making sure the PKI environment is OK

CheckIfExist $subject || DieLogging 13 "VerifyCert: Subject $2 does not exists!"

local result=$(openssl verify -CApath $dir/crl/ -crl_check $dir/certs/$subject.pem) || DieLogging 126 "VerifyCert cannot verify certificate for subject $subject" 
local regexok=".*$subject.pem: OK\$"
local regexrevoked=".*:certificate revoked\$"
local regexexpired=".*:certificate has expired"


if [[ $result =~ $regexok ]]; then
  LogToSyslog "debug" "VerifyCert check VALID: $result"
  return 0
elif [[ $result =~ $regexrevoked ]]; then
  LogToSyslog "debug" "VerifyCert check REVOKED: $result"
  return 101
elif [[ $result =~ $regexexpired ]]; then
  LogToSyslog "debug" "VerifyCert check EXPIRED: $result"
  return 102
else
  LogToSyslog "warn" "VerifyCert check UNKNOWN: $result" # warn log leel as we should know (being more precise)
  return 100
fi
}

PrintCRLInfo() {
# Will print human readable info about current CRL

CheckEnv # Start making sure the PKI environment is OK

echo "Printing current CRL informations:"
openssl crl -inform PEM -in $dir/crl/current_crl.pem -text -noout || DieLogging 66 "PrintCRLInfo: error trying to print CRL information"

}

PrintVerifyInfo() {
# @ill print verify info on $subject
local subject=$1

CheckIfExist $subject || DieLogging 13 "VerifyCert: Subject $subject does not exists!"

$(VerifyCert $subject) ; local verifycert=$?
case "$verifycert" in
  0)
    local certcurrentstatus="VALID"
    PrintMessage "info" "Certificate for $subject is: $COL_GREEN$certcurrentstatus$COL_RESET"
    return 0
    ;;
 101)
    local certcurrentstatus="REVOKED"
    PrintMessage "info" "Certificate for $subject is: $COL_RED$certcurrentstatus$COL_RESET"
    return 101
    ;;
 102)
    local certcurrentstatus="EXPIRED"
    PrintMessage "info" "Certificate for $subject is: $COL_RED$certcurrentstatus$COL_RESET"
    return 102
    ;;
 100)
    local certcurrentstatus="UNKNOWN"
    PrintMessage "info" "Certificate for $subject is: $COL_RED$certcurrentstatus$COL_RESET"
    return 100
    ;;
   *)
    local certcurrentstatus="UNKNOWN"
    PrintMessage "warn" "Certificate for $subject is: $COL_RED$certcurrentstatus$COL_RESET"
    LogToSyslog "warn" "PrintVerifyInfo: stated an UNKNOWN status of certificate for $subject - not a normal condition"
    return 103
esac

}


InfoOnCRL() {
# Will print human readable infos regarding CRL

CheckEnv # Start making sure the PKI environment is OK

local crlissuer=$(openssl crl -inform PEM -in $dir/crl/current_crl.pem -noout -issuer -nameopt RFC2253) || DieLogging 66 "PrintCAInfo> cannot stat on CRL issuer"
local lastcrldate=$(openssl crl -inform PEM -in $dir/crl/current_crl.pem -noout -lastupdate) || DieLogging 66 "PrintCAInfo> cannot stat on CRL lastupdate"
local nextcrldate=$(openssl crl -inform PEM -in $dir/crl/current_crl.pem -noout -nextupdate) || DieLogging 66 "PrintCAInfo> cannot stat on CRL nextupdate"
local crlnumber=$(openssl crl -inform PEM -in $dir/crl/current_crl.pem -noout -crlnumber) || DieLogging 66 "PrintCAInfo> cannot stat on CRL number"
local crlnumbernb=${crlnumber//crlNumber=/}
local revokedcertnb=$(openssl crl -inform PEM -in $dir/crl/current_crl.pem -noout -text | grep "Serial Number:" | /usr/bin/wc -l) || DieLogging 66 "PrintCAInfo> cannot stat on CRL nextupdate"

echo "Certificate Revocation List (CRL) info:"
echo "---------------------------------------"
echo "Certificate Authority that issued:          ${crlissuer//issuer=/}"
echo "Current CRL:"
echo " - CRL serial number:                       $((0x${crlnumbernb//[[:space:]]/})) (hex: ${crlnumbernb//[[:space:]]/}) "
echo " - CRL produced on:                         ${lastcrldate//lastUpdate=/}"
echo " - CRL next update on (at max):             ${nextcrldate//nextUpdate=/}"
echo ""
echo "Number of Revoked Certificates:             ${revokedcertnb//[[:space:]]/}"
echo ""
echo -e "Current Status:                            $COL_GREEN OK$COL_RESET" # Sure as CheckEnv will deal the case if the CRL was expired - see #18
echo ""
#TODO: where is the distribution point - to be done when coded (see #5 and #10)


}

InfoOnCert() {
# Will print human readable infos on certificates
local subject=$1

CheckEnv # Start making sure the PKI environment is OK

CheckIfExist $subject || DieLogging 13 "PrintCertInfo: Subject $subject does not exists!"

local certissuer=$(openssl x509 -noout -in $dir/certs/$subject.pem -issuer -nameopt RFC2253) || DieLogging 66 "InfoOnCert: cannot stat Issuer from $subject certificate"
local certsubject=$(openssl x509 -noout -in $dir/certs/$subject.pem -subject -nameopt RFC2253) || DieLogging 66 "InfoOnCert: cannot stat Subject from $subject certificate"
local certserial=$(openssl x509 -noout -in $dir/certs/$subject.pem -serial) || DieLogging 66 "InfoOnCert: cannot stat Serial from $subject certificate"
local certemail=$(openssl x509 -noout -in $dir/certs/$subject.pem -email) || DieLogging 66 "InfoOnCert: cannot stat Email from $subject certificate"
local certalias=$(openssl x509 -noout -in $dir/certs/$subject.pem -alias) || DieLogging 66 "InfoOnCert: cannot stat Alias from $subject certificate"
local certpurpose=$(openssl x509 -noout -in $dir/certs/$subject.pem -purpose) || DieLogging 66 "InfoOnCert: cannot stat Alias from $subject certificate"
local certstartdate=$(openssl x509 -noout -in $dir/certs/$subject.pem -startdate) || DieLogging 66 "InfoOnCert: cannot stat StartDate from $subject certificate"
local certenddate=$(openssl x509 -noout -in $dir/certs/$subject.pem -enddate) || DieLogging 66 "InfoOnCert: cannot stat EndDate from $subject certificate"
$(VerifyCert $subject) ; local verifycert=$?
case "$verifycert" in
  0)
    local certcurrentstatus="VALID"
    local COL_TO_USE=$COL_GREEN
    ;;
 101)
    local certcurrentstatus="REVOKED"
    local COL_TO_USE=$COL_RED
    ;;
 102)
   local certcurrentstatus="EXPIRED"
    local COL_TO_USE=$COL_RED
    ;;
 100)
   local certcurrentstatus="UNKNOWN"
    local COL_TO_USE=$COL_RED
    ;;
   *)
   local certcurrentstatus="UNDETERMINED"
    local COL_TO_USE=$COL_YELLOW
   LogToSyslog "warn" "InfoOnCert: stated an UNDETERMINE status of certificate for $subject - anormal condition"
esac

local certtype=$(grep x509_extension $dir/csr/$subject.conf) || DieLogging 126 "InfoOnCert: cannot stat the CSR configuration file for $subject certificate"
certtype=${certtype//*[[:space:]]=\ /}
certtype=${certtype#spki_type_}
case "$certtype" in
  user)
    local certtypestring="USER certificate"
    local certcapacities=$spki_type_user_extensions
    ;;
  server)
    local certtypestring="SERVER certificate"
    local certcapacities=$spki_type_server_extensions
    ;;
  *)
    local certtypestring="UNKNOWN certificate"
    local certcapacities="UNKNOWN"
    LogToSyslog "warn" "InfoOnCert found an UNKNOWN type of certificate for certificate $subject"
esac

echo "Certificate usefull informations:"
echo "---------------------------------"
echo "Certificate issued for subject:               $subject"
echo " - Delivered by:                              ${certissuer//issuer=\ /}"
echo " - for subject DN:                            ${certsubject//subject=\ /}"
echo " - Certificate serial number:                 $((0x${certserial//serial=/})) (hex: ${certserial//serial=/})"
echo ""
echo "Certificate Type:                             $certtypestring" 
echo " - Capacities:                                $certcapacities"
echo " - Attached to email:                         $certemail"
echo " - Alias:                                     $certalias"
echo ""
echo "Certificate Validity:"
echo " - valid from:                                ${certstartdate//notBefore=/}"
echo "           to:                                ${certenddate//notAfter=/}"
echo ""
echo -e "Current Status:                               $COL_TO_USE$certcurrentstatus$COL_RESET"
echo ""

}

InfoOnCA() {
# Will print human readable info regarding the CA

CheckEnv # Start making sure the PKI environment is OK

local myhost=$HOSTNAME
local operatingsystem=$(uname -s) || DieLogging 125 "PrintCAInfo: cannot stat Operating System"
local opensslversion=$(openssl version) || DieLogging 66 "PrintCAInfo: cannot stat on OpenSSL version"
local caissuer=$(openssl x509 -noout -in $dir/certs/ca.pem -issuer -nameopt RFC2253) || DieLogging 66 "PrintCAInfo: cannot stat CA issuer from CA certificate"
local castartdate=$(openssl x509 -noout -in $dir/certs/ca.pem -startdate) || DieLogging 66 "PrintCAInfo: cannot stat CA startdate from CA certificate"
local caenddate=$(openssl x509 -noout -in $dir/certs/ca.pem -enddate) || DieLogging 66 "PrintCAInfo: cannot stat CA enddate from CA certificate"
local validcert=$(grep "^V" $dir/datas/index | /usr/bin/wc -l) || DieLogging 126 "PrintCAInfo: cannot count Valid certificates in CA index file"
local revokedcert=$(grep "^R" $dir/datas/index | /usr/bin/wc -l) || DieLogging 126 "PrintCAInfo: cannot count Revoked certificates in CA index file"
local expiredcert=$(grep "^E" $dir/datas/index | /usr/bin/wc -l) || DieLogging 126 "PrintCAInfo: cannot count Expired certificates in CA index file"
local lastcrldate=$(openssl crl -inform PEM -in $dir/crl/current_crl.pem -noout -lastupdate) || DieLogging 66 "PrintCAInfo> cannot stat on CRL lastupdate"
local nextcrldate=$(openssl crl -inform PEM -in $dir/crl/current_crl.pem -noout -nextupdate) || DieLogging 66 "PrintCAInfo> cannot stat on CRL nextupdate"
echo "General info on the Certificate Authority:"
echo "------------------------------------------"
echo "Host running SPKI:                          $myhost"
echo "Operating System:                           $operatingsystem"
echo "Cryptographic Engine:                       $opensslversion"
echo " - CA Distinguished Name:                   ${caissuer//issuer=\ /}"
echo " - Start Validity on:                       ${castartdate//notBefore=/}"
echo " - End Validity on:                         ${caenddate//notAfter=/}"
echo ""
echo "Issued certificates:"
echo " - Valid:                                   ${validcert//[[:space:]]/}"
echo " - Revoked:                                 ${revokedcert//[[:space:]]/}"
echo " - Expired:                                 ${expiredcert//[[:space:]]/}"
echo ""
echo "CRL infos:"
echo " - Last CRL produced on:                    ${lastcrldate//lastUpdate=/}"
echo " - Next CRL to be produced on:              ${nextcrldate//nextUpdate=/}"
echo ""
echo -e "Current Status:                            $COL_GREEN OK$COL_RESET"
echo ""
}

PrintCertInfo() {
# Will print human readable info regarding a given certificate - if exists (else die)
local subject=$1

CheckEnv # Start making sure the PKI environmnent is OK

CheckIfExist $subject || DieLogging 13 "PrintCertInfo: Subject $subject does not exists!"
echo "Printing certificate information for $subject:" 
openssl x509 -text -in $dir/certs/$subject.pem -noout || DieLogging 66 "PrintCertInfo: error trying to print Cert information for $subject"
}


DieLogging() {
# exit with error code and associated message, sysloging too.
local errorcode=$1
local message=$2

case "$errorcode" in
  0|100)
    PrintMessage "warn" "Nobody should die with exit return code 0 or 100 - called with message $message"
    ;;
  12|103)
    PrintMessage "warn" "$message"
    ;;
  9|15|66|67)
    PrintMessage "emerg" "$message"
    ;;
  1|2|126|255)
    PrintMessage "crit" "$message"
    ;;
  15)
    PrintMessage "alert" "$message"
    ;;
  13|14)
    PrintMessage "debug" "$message"
    ;;
  10|11)
    PrintMessage "info" "$message"
    ;;
  *)
    PrintMessage "warn" "Unknown Error Code($errorcode): called with message $message"
esac
    PrintMessage "info" "Exiting with Error Code $errorcode ($message)..."
exit $errorcode
}

LogToSyslog() {
# will log to syslog (anyway) - and eventually to specific log file too if configuration ask for that
local priority=$1
local message=$2
local timestamp=$(date -u "+%Y-%m-%dT%H:%M:%S+0000") 

case "$priority" in 
  debug)
    if [ "$debugmode" == "yes" ]; then
      if [ "$specificlogfile" == "yes" ]; then
        echo "$timestamp : $loggertag-$priority : $message" >> $logtofile
      fi
      /usr/bin/logger -p $loggerchan.$priority -t $loggertag "$priority - $message"
    fi
    ;;
  emerg|alert|crit|notice|info)
    /usr/bin/logger -p $loggerchan.$priority -t $loggertag "$priority - $message"
    if [ "$specificlogfile" == "yes" ]; then
      echo "$timestamp : $loggertag-$priority : $message" >> $logtofile
    fi
    ;;
  err|error)
    /usr/bin/logger -p $loggerchan.err -t $loggertag "$priority - $message"
    if [ "$specificlogfile" == "yes" ]; then
      echo "$timestamp : $loggertag-$priority : $message" >> $logtofile
    fi
    ;;
  warn|warning)
    /usr/bin/logger -p $loggerchan.warn -t $loggertag "$priority - $message"
    if [ "$specificlogfile" == "yes" ]; then
      echo "$timestamp : $loggertag-$priority : $message" >> $logtofile
    fi
    ;;
  *)
    /usr/bin/logger -p $loggerchan.warning -t $loggertag "notice - syslog priority unknown -> $priority"
    /usr/bin/logger -p $loggerchan.warning -t $loggertag "$priority - $message"
    if [ "$specificlogfile" == "yes" ]; then
      echo "$timestamp : $loggertag-$priority : $message" >> $logtofile
    fi
esac
}

PrintMessage() {
# Display (console) the message, and syslog it too if not "info" priority
local priority=$1
local message=$2
case "$priority" in
  debug)
    echo "----> $message" 
    if [ "$debugmode" == "yes" ]; then
      LogToSyslog "$priority" "$message"
    fi
    ;;
  info)
    echo -e "----> $message"
    if [ "$debugmode" == "yes" ]; then
      LogToSyslog "$priority" "$message"
    fi
    ;;
  warn|warning)
    echo -e "$COL_YELLOW##### $message$COL_RESET"
    LogToSyslog "$priority" "$message"
    ;;
  crit|alert)
    echo -e "$COL_RED!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!$COL_RESET"
    echo -e "$COL_RED!!!!! $message$COL_RESET"
    LogToSyslog "$priority" "$message"
    ;;
  emerg)
    echo -e "$COL_RED********************************************************************$COL_RESET"
    echo -e "$COL_RED********************************************************************$COL_RESET"
    echo -e "$COL_RED********************************************************************$COL_RESET"
    echo -e "$COL_RED*****$COL_RESET"
    echo -e "$COL_RED***** $message$COL_RESET"
    LogToSyslog "$priority" "$message"
    ;;
  *)
    echo "????($priority)???? $message"
    LogToSyslog "warn" "PrintMessage called with an unsupported priority ($priority)"
esac
}

Usage() {
# Print user help
echo "Copyright (C) Senso-Rezo - SPKI (http://github.com/olemaire/spki)

Usage: spki <option> (<subject>) 

Available options are:
    --initialize                     Initialize a new Certiciate Authority
    --issue <type> <subject>         Issue a certificate of <type> for <subject>
            server <fqdn>              issue a Server certificate
            user <email>               issue an User certificate
    --verify <email,fqdn>            Verify a given certificate
    --renew <email,fqdn> (reason)    Renew a given certificate
    --revoke <email,fqdn> (reason)   Revoke a given certificate
    --crl                            Generate a Certificate Revocation List
    --print <email,fqdn,ca,crl>      Will display a raw print of certificate/CRL
    --info (email,fqdn,ca,crl)       Will give human readable information on SPKI certificate/CA/CRL
    --status                         Will give an overall status of operatin of SPKI
    --help                           Display this short help message

Exemples:
        spki --issue server www.senso-rezo.org
	spki --issue user olivier.lemaire@senso-rezo.org
        spki --info www.senso-rezo.org
        spki --revoke ldap.senso-rezo.org
	spki --revoke www.senso-rezo.org keyCompromise
	spki --renew olivier.lemaire@senso-rezo.org
	spki --crl
        spki --print crl

"
}

## MAIN

CheckConfig

case "$1" in
  -initialize|--initialize|initialize)
    InitializeCA
    ;;
  -issue|--issue|issue)
    IssueCert $2 $3
    ;;
  -verify|--verify|verify)
    PrintVerifyInfo $2
    ;;
  -renew|--renew|renew)
    RenewCert $2 $3 $4
    ;;
  -revoke|--revoke|revoke)
    RevokeCert $2 $3 $4
    ;;
  -crl|--crl|crl)
    if GenerateCRL ; then
      echo "A new CRL has been generated"
    fi
    ;;
  -print|--print|print)
    case "$2" in
      crl)
        PrintCRLInfo 
        ;;
      ""|ca)
        PrintCertInfo ca
        ;;
      *)
        PrintCertInfo $2
    esac
    ;;
  -info|--info|info)
    case "$2" in
      crl)
        InfoOnCRL
        ;;
      ""|ca)
        InfoOnCA
        ;;
      *)
        InfoOnCert $2
    esac
    ;;
  -status|--status|status)
    if CheckEnv ; then
      echo -e "$COL_GREEN""OK$COL_RESET"
    fi
    ;;
  -h|-help|--help|help)
    Usage
    ;;
  "")
    echo "SPKI Copyright (C) Senso-Rezo - SPKI (http://github.com/olemaire/spki)"
    echo ""
    echo "Please RTFM: spki --help"
    echo ""
    ;;
  *)
    DieLogging 12 "SPKI invalid function call $1 (try --help)"
esac

# - This Is The End
